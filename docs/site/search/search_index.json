{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Haskell (9.2.5)","text":"<p>Haskell is a general purpose programming language. It is unique in being both very principled in its design (pure functions only, simple syntax, very expressive types), but also practical (heavily-engineered compiler that can generate fast code).</p> <ul> <li>Pros: highly modular code, low boilerplate, easy and safe refactoring</li> <li>Cons: no manual memory management, some gaps in ecosystem</li> </ul> <p>Salient properties include:</p> <ul> <li>functional</li> <li>pure and immutable</li> <li>custom static types and automatically inferred type annotations</li> <li>lazy</li> </ul> <p>Try it online</p> <p>Get set up</p>"},{"location":"#how-to-use-this-guide","title":"How to use this guide","text":"<p>If you're totally new to Haskell, we recommend reading through the tabs at the top of the page from the left to the right.</p> <p>Feel free also to use this guide as a reference. For example, you can search the docs like so if you need a quick example of how to use a certain construction like <code>case</code>.</p>  <p>Ask questions about pages you don't understand via the <code>Comments</code> section at the bottom of each page.</p>  <p>Disclaimer</p> <p>This documentation is a personal project, and not official Haskell documentation. Contributions are encouraged, by submitting a PR. See here for a style guide.</p>"},{"location":"#haskell-version","title":"Haskell Version","text":"<p>This guide is written for series 9 of the Glasgow Haskell Compiler (GHC). Almost all the content is applicable to older versions, but if in doubt, use GHC 9.2.5.</p>"},{"location":"basics/createData/","title":"Creating types","text":""},{"location":"basics/createData/#products","title":"Products","text":"<p>You can make your own types like this:</p> TraditionalModern (GADT)   <pre><code>data Square = Sq Int Int -- (1)!\n</code></pre> <ol> <li>The choice of the names <code>Square</code> and <code>Sq</code> are both arbitrary. Both must be capitalized.</li> </ol>   <pre><code>data Square where -- (1)!\n    Sq :: Int -&gt; Int -&gt; Square\n</code></pre> <ol> <li>This requires the GADT extension, which is included with GHC2021.</li> </ol>    <p>This creates a new type <code>Square</code>; values of type <code>Square</code> look like <code>Sq i j</code>, where <code>i</code> and <code>j</code> are <code>Int</code>s.</p> <p><code>Sq</code> is referred to as a data constructor, and is a Haskell function, with type shown explicitly in the \"modern\" version above.</p> repl example<pre><code>&gt; :t Sq 5 4\nSq 5 4 :: Square\n&gt; :t Sq 5 True\n\"Couldn't match expected type \u2018Int\u2019 with actual type \u2018Bool\u2019\"\n&gt; :t Sq \nSq :: Int -&gt; (Int -&gt; Square) -- (1)!\n&gt; :t Sq 3\nSq 3 :: Int -&gt; Square -- (2)!\n</code></pre> <ol> <li> <p>Actually, the repl will drop the brackets, and show: <code>Int -&gt; Int -&gt; Square</code>.</p> </li> <li> <p>If this is unclear, see here for more info.</p> </li> </ol>  Tip <p>The type <code>Square</code> contains the same information as the product type <code>(Int, Int)</code>. These types are different, in the sense that code which expects one will not work with the other, but it is easy to write loss-less functions between them:</p> <pre><code>fromSq :: Square -&gt; (Int, Int)\nfromSq (Sq i j) = (i, j)\n\ntoSq :: (Int, Int) -&gt; Square\ntoSq (i, j) = Sq i j\n</code></pre>   <p>Note</p> <p>The number of types following <code>Sq</code> can be 0 or more. For example: repl example<pre><code>&gt; data SquareAlt = SqAlt Int\n&gt; data SquareAlt2 = SqAlt2\n&gt; :t SqAlt \n</code></pre></p> <p>If the number of types is <code>1</code>, you will see a suggestion to replace <code>data</code> with <code>newtype</code>. See more about <code>newtype</code> here</p>"},{"location":"basics/createData/#records","title":"Records","text":"<p>You can also name entries:</p> TraditionalModern (GADT)   <pre><code>data Entity = Sq {row :: Int, col :: Int}\n</code></pre>   <pre><code>data Entity where\n  Sq :: {row :: Int, col :: Int} -&gt; Entity\n</code></pre>    <p><code>row</code> and <code>col</code> are now accessing functions:</p> repl example<pre><code>&gt; entity = Sq 4 5\n&gt; :t entity\nentity :: Entity\n&gt; row entity\n4\n&gt; col entity\n5\n&gt; :t row\nrow :: Entity -&gt; Int\n&gt; :t col\ncol :: Entity -&gt; Int\n</code></pre>"},{"location":"basics/createData/#sums","title":"Sums","text":"TraditionalModern (GADT)   <pre><code>data Entity = Sq Int Int | Player Bool -- (1)!\n</code></pre> <ol> <li><code>Entity</code> is a type, but <code>Sq</code> and <code>Player</code> are values belonging to that type</li> </ol> <p>The vertical bar <code>|</code> indicates that an <code>Entity</code> is either made with <code>Sq</code> or with <code>Piece</code>:</p>   <pre><code>data Entity where\n    Sq :: Int -&gt; Int -&gt; Entity -- (1)!\n    Player :: Bool -&gt; Entity\n</code></pre> <ol> <li>This requires the GADT extension, which is included with GHC2021.</li> </ol> <p>The newline indicates that an <code>Entity</code> is either made with <code>Sq</code> or with <code>Player</code>:</p>    repl example<pre><code>&gt; Sq 4 6\nSq 4 6 :: Entity\n&gt; :t Player False\nPlayer False :: Entity\n&gt; :t Player \nPlayer :: Bool -&gt; Entity\n</code></pre>  Tip <p>The type <code>Entity</code> contains the same information as the type <code>Either (Int, Int) Bool</code>, and one can write loss-less functions between them:</p> <pre><code>fromEntity :: Entity -&gt; Either (Int, Int) Bool\nfromEntity (Sq i j) = Left (i, j)\nfromEntity (Player bool) = Right bool\n\ntoEntity :: Either (Int, Int) Bool -&gt; Entity\ntoEntity (Left (i ,j)) = Sq i j\ntoEntity (Right bool) = Player bool\n</code></pre>   <p>Note</p> <p>You can combine products and sums, using your own types:</p> <pre><code>data ChessPiece = Piece PieceType Color | SquareType Square -- (1)!\ndata Color = Black | White\ndata PieceType = Bishop | Rook\ndata Square = Sq Int Int\n</code></pre> <ol> <li>Note that Haskell is unconcerned by the order of definitions: the definition of <code>Color</code> comes after its use in the definition of <code>ChessPiece</code>. </li> </ol>"},{"location":"basics/createData/#parameterized-types","title":"Parameterized types","text":"<p>One can also create types which take another type as a parameter:</p> <pre><code>data Piece c = Bishop c | Knight c | King c\n</code></pre> <p>This creates <code>Piece Bool</code>, <code>Piece Int</code>, and so on:</p> repl example<pre><code>&gt; data Piece c = Bishop c | Knight c | King c\n&gt; :t Knight True\nKnight True :: Piece Bool\nlet four = 4 :: Int\n&gt; :t King four\nKing four :: Piece Int\n&gt; :t King (King True)\nKing (King True) :: Piece (Piece Bool)\n</code></pre>  Note <p>One can think of <code>Piece</code> as a function on types, which gives a type <code>c</code>, produces a type <code>Piece c</code>. </p> <p>To make this idea explicit, one can say that <code>Piece</code> has kind <code>Type -&gt; Type</code>, where kind is a name for the types that types themselves have. </p>"},{"location":"basics/createData/#recursive-types","title":"Recursive types","text":"<pre><code>data BinTree = Leaf Int | Branch BinTree BinTree\n</code></pre> <p>Here, <code>BinTree</code> is being used recursively in its own definition. Values of <code>BinTree</code> include:</p> repl example<pre><code>&gt; data BinTree = Leaf Int | Branch BinTree BinTree\n&gt; :t Leaf 4\nLeaf 4 :: BinTree\n&gt; :t Leaf True\n&gt; :t Branch (Leaf 4) (Leaf 5)\nBranch (Leaf 4) (Leaf 5) :: BinTree\n&gt; :t Branch (Leaf 3) ((Branch (Leaf 6) (Leaf 8)))\nBranch (Leaf 3) ((Branch (Leaf 6) (Leaf 8))) :: BinTree\n</code></pre> <p>Recursive types can also be parametrized:</p> <pre><code>data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)\n</code></pre> repl example<pre><code>data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)\n&gt; :t Leaf True\nLeaf True :: BinTree Bool\n&gt; :t Leaf ()\nLeaf () :: BinTree ()\n&gt; :t Branch (Leaf True) (Leaf False)\nBranch (Leaf True) (Leaf False) :: BinTree Bool\n&gt; :t Branch (Leaf True) (Leaf ())\n\"Couldn't match expected type \u2018Bool\u2019 with actual type \u2018()\u2019\" -- (1)!\n</code></pre> <ol> <li>The definition of <code>Branch</code> requires that the left and right branch be trees of the same type, which is why this doesn't work.</li> </ol> <p>Here is a more complex recursive type and a program of that type:</p> <pre><code>data Machine a b = M (a -&gt; (b, Machine a b))\n\nmachine :: Machine Int Int\nmachine = machine1 where \n\n    machine1 :: Machine Int Int\n    machine1 = M (\\i -&gt; (i, if i &gt; 10 then machine2 else machine1))\n\n    machine2 :: Machine Int Int\n    machine2 = M (\\i -&gt; (0, machine2))\n</code></pre>  <p>Note</p> <p>The list type can be defined recursively in this way:</p> <pre><code>data List a = EmptyList | HeadThenList a (List a)\n</code></pre> <p>In fact, the <code>[a]</code> type in Haskell is defined in this way, with the <code>[1,2,3]</code> being extra syntax for convenience:</p> <pre><code>data [] a = [] | a : [a] -- (1)!\n</code></pre> <ol> <li><code>:</code> is the data constructor, analogous to <code>HeadThenList</code> above, but written infix. <code>[]</code> is analogous to <code>EmptyList</code>.</li> </ol>"},{"location":"basics/createData/#synonyms","title":"Synonyms","text":"<p>One can also give new names to existing types:</p> <pre><code>type Number = Double\n</code></pre>  <p>Note</p> <p>Here, <code>Number</code> and <code>Double</code> are not distinguished as separate types by the compiler, so replacing one by the other in a type signature will always be fine. This would not be true for:</p> <pre><code>data Number = N Double\n</code></pre>  <p>This can be useful for readability, particularly for quite complex types:</p> <pre><code>type Failure = Text\ndata Result = ...\ntype Program = Either Failure Result\n</code></pre>"},{"location":"basics/createData/#isomorphic-types","title":"Isomorphic types","text":"<p>Two types are isomorphic (or more colloquially, the same) if there are functions to convert between them in both directions that are loss-less:</p> repl example<pre><code>data WrappedInt = MkW {getInt :: Int}\n\n&gt; :t MkW \nMkW :: Int -&gt; WrappedInt -- one direction\n&gt; :t getInt \ngetInt :: WrappedInt -&gt; Int -- the other direction\n\n&gt; :t (getInt . MkW)\n(getInt . MkW) :: Int -&gt; Int\n&gt; (getInt . MkW) 4 -- (1)!\n4\n\n&gt; :t (MkW . getInt)\n(MkW . getInt) :: WrappedInt -&gt; WrappedInt -- (2)!\n</code></pre> <ol> <li><code>(getInt . MkW)</code> is the identity function.</li> <li><code>(MkW . getInt)</code> is also the identity function.</li> </ol> <p>Types which are isomorphic can be regarded as \"the same\" for practical purposes, since you can always convert between them, although they may have different performance characteristics. They may also have different typeclass instances.</p>"},{"location":"basics/createData/#reference-table-of-isomorphic-types","title":"Reference table of isomorphic types","text":"A type An isomorphic type     <code>data WrappedInt = MkW Int</code> <code>Int</code>   <code>data Wrapped a = MkW a</code> <code>a</code>   <code>data Unit = U</code> <code>()</code>   <code>data Pair = P Int Bool</code> <code>(Int, Bool)</code>   <code>data OneOf = I Int | B Bool</code> <code>Either Int Bool</code>   <code>a -&gt; b -&gt; c</code> <code>(a, b) -&gt; c</code>   <code>Bool -&gt; a</code> <code>(a, a)</code>   <code>Maybe a</code> <code>Either () a</code>   <code>Reader e a</code> <code>e -&gt; a</code>   <code>State s a</code> <code>s -&gt; (a, s)</code>   <code>Except err a</code> <code>Either err a</code>   <code>ReaderT e m a</code> <code>e -&gt; m a</code>   <code>StateT s m a</code> <code>s -&gt; m (a, s)</code>   <code>ExceptT err m a</code> <code>m (Either err a)</code>"},{"location":"basics/functions/","title":"Functions","text":""},{"location":"basics/functions/#function-application","title":"Function application","text":"<p>Given a function, such as:</p> <pre><code>add1 x = x + 1\n</code></pre> <p>we can call it on input as follows:</p> <pre><code>add1 2\n&gt; 3\n</code></pre> <p>One can also write <code>add1(2)</code>, but Haskell convention is to avoid brackets where possible.</p>  <p>Note</p> <p>One can choose any name for an argument (provided it is alphanumeric and starts with a lowercase letter).</p> <p>If you have named something else by the same name elsewhere, that is fine:</p> <pre><code>x = True\nadd1 x = x + 1\n</code></pre> <p>The occurrence of <code>x</code> on the right of line 2 refers to the occurrence on the left of line 2, not the occurrence on line 1.</p>"},{"location":"basics/functions/#arguments","title":"Arguments","text":"<p>In Haskell, a function has a single argument, but that argument can be a tuple of multiple values:</p> <pre><code>exampleFunc :: (Int, Int) -&gt; Int\nexampleFunc (i1, i2) = i1 + i2\n</code></pre>"},{"location":"basics/functions/#currying","title":"Currying","text":"<p>Another approach to taking multiple arguments, more commonly used, is shown here:</p> <pre><code>exampleFunc :: Int -&gt; (Int -&gt; Int) -- (1)!\nexampleFunc i1 i2 = i1 + i2\n</code></pre> <ol> <li>By convention in Haskell, <code>Int -&gt; Int -&gt; Int</code> means <code>Int -&gt; (Int -&gt; Int)</code>, not <code>(Int -&gt; Int) -&gt; Int</code>. </li> </ol> <p>As the type signature indicates, the first argument is an integer, but the output is a function which takes a second integer and returns an integer. </p> <p>Accordingly, we can apply <code>exampleFunc</code> to an integer, say <code>5</code>, and obtain an \"add 5\" function:</p> <pre><code>&gt; :t exampleFunc 4\n(Int -&gt; Int)\n\n&gt; add4 = exampleFunc 4\n&gt; add4 5\n9\n\n-- or directly\n&gt; (exampleFunc 4) 5 -- (1)!\n9\n</code></pre> <ol> <li>By convention in Haskell, <code>exampleFunc 4 5</code> means <code>(exampleFunc 4) 5</code>.</li> </ol> <p>This is often referred to as partial application. <code>exampleFunc</code> would be described as a curried function.</p>  <p>Hint</p> <p>When you see a function with a type like <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; Type4</code> (which brackets as: <code>Type1 -&gt; (Type2 -&gt; (Type3 -&gt; Type4))</code> ), you can think of it as taking <code>Type1</code>, <code>Type2</code> and <code>Type3</code> as inputs, and outputting <code>Type4</code>. </p>"},{"location":"basics/functions/#partial-application-for-types","title":"Partial application for types","text":"<p>The same holds for types and their kinds:</p> repl example<pre><code>&gt; :kind Either\nEither :: * -&gt; (* -&gt; *)\n&gt; :kind Either Bool\nEither Bool :: * -&gt; *\n&gt; :kind Either Bool Int\nEither Bool Int :: *\n</code></pre>"},{"location":"basics/functions/#pattern-matching-on-sum-types","title":"Pattern matching on sum types","text":"<p>When defining a function, you can pattern match:</p> <pre><code>exampleFunc :: Either Int Bool -&gt; Int\nexampleFunc (Left i) = i -- (1)!\nexampleFunc (Right True) = 1\nexampleFunc (Right _) = 0 -- (2)!\n</code></pre> <ol> <li> <p><code>i</code> matches any <code>Int</code>. It has to be an <code>Int</code> because the input has type <code>Either Int Bool</code> (<code>Int</code> is on the left).</p> </li> <li> <p>The underscore <code>_</code> matches <code>Bool</code>. It has to be a <code>Bool</code> because the input has type <code>Either Int Bool</code> (<code>Bool</code> is on the right).</p> </li> </ol> <p>Here is how the function behaves:</p> <pre><code>&gt; exampleFunc (Left 6)\n6\n&gt; exampleFunc (Right True)\n1\n&gt; exampleFunc (Right False)\n0\n</code></pre> <p>Here, <code>(Left i)</code>, <code>(Right True)</code> and <code>(Right _)</code> are all patterns.</p> <p>The patterns are matched top-down. For example, if the function were:</p> <pre><code>exampleFunc :: Either Int Bool -&gt; Int\nexampleFunc (Left i) = i \nexampleFunc (Right _) = 0 \nexampleFunc (Right True) = 1\n</code></pre> <p>Then:</p> <pre><code>&gt; exampleFunc (Right True)\n0\n</code></pre> <p>because line 3 would be matched before line 4 was reached.</p>"},{"location":"basics/functions/#pattern-matching-on-product-types","title":"Pattern matching on product types","text":"<p>The above example concerns a type that is either a <code>Right True</code> or a <code>Right False</code> or a  <code>Left 0</code>, or a <code>Left 1</code>...In other words, it is a sum type.</p> <p>Pattern matching also works with products (and products of sums, sums of products, and so on):</p> repl example<pre><code>&gt; ex = (True, False)\n&gt; (b1, b2) = ex\n&gt; b1\nTrue\n&gt; b2\nFalse\n\n-- with a custom type\n&gt; data Entity = Sq Int Bool\n&gt; entity = Sq 4 False\n&gt; Sq i b = entity\n&gt; i\n4\n&gt; b\nFalse\n</code></pre> <p>This works also in functions:</p> repl example<pre><code>&gt; data Color = White | Black deriving Show\n&gt; data PieceType = Bishop | Knight deriving Show\n&gt; data Piece = P PieceType Color deriving Show\n&gt; getColor (P _ c) = c\n&gt; getColor (P Bishop White)\nWhite\n</code></pre>  <p>Note</p> <p>Patterns can be arbitrarily deeply nested, as in:</p> <pre><code>data Color = Black | White\ndata Piece = Bishop Color | Knight Color \n\ngetColor :: Either Bool Piece -&gt; Maybe Color\ngetColor (Right (Bishop c)) = Just c\ngetColor (Right (Knight c)) = Just c\ngetColor (Left _) = Nothing\n</code></pre> <p>And also used with recursive types</p> repl example<pre><code>&gt; data BinTree = Leaf Char | Branches BinTree BinTree\n&gt; leftRightLeaf (Branches (Branches _ (Leaf c))  _) = c\n&gt; tree = Branches (Branches (Leaf 'a') (Leaf 'c')) (Leaf 'b')  \n&gt; leftRightLeaf tree\n'c'\n</code></pre>"},{"location":"basics/functions/#pattern-matching-lists","title":"Pattern matching lists","text":"<p>Pattern matching also applies to lists, since they are recursive types:</p> repl example<pre><code>&gt; ls@(head:tail) = [1,2,3]\n&gt; head\n1\n&gt; tail\n[2,3]\n&gt; ls\n[1,2,3]\n</code></pre>  <p>Tip</p> <p>A classic example of returning an error when getting the first element of an empty list:</p> <pre><code>getFirstElement :: [b] -&gt; Either String b\ngetFirstElement ( x : _ ) = Right x\ngetFirstElement [] = Left \"the list is empty\"\n</code></pre>"},{"location":"basics/functions/#using-in-patterns","title":"Using @ in patterns","text":"repl example<pre><code>-- first example\n&gt; let whole@(a,b) = ('a', True)\n&gt; a\n'a'\n&gt; b\nTrue\n&gt; whole\n('a',True)\n\n-- second example\n&gt; let whole@(a, left@(b, c)) = ('a', (True, ()))\n&gt; a\n'a'\n&gt; b\nTrue\n&gt; c\n()\n&gt; whole\n('a',(True,()))\n&gt; left\n(True,())\n</code></pre> <p>And in a function:</p> <pre><code>exampleFunc :: (Int, Bool) -&gt; (Int, Bool)\nexampleFunc whole@(int,bool) \n    | even int = whole\n    | otherwise = (int - 1, not bool)\n</code></pre>"},{"location":"basics/syntax/","title":"Syntactic constructs","text":""},{"location":"basics/syntax/#indentation","title":"Indentation","text":"<p>Haskell is indentation sensitive, like Python. Tabs or spaces are fine.</p> <pre><code>example input = result &lt;&gt; \" tree\" where\n    result = case input of\n        True -&gt; \"red\"\n        False -&gt; \"black\"\n</code></pre>"},{"location":"basics/syntax/#infixing-and-sections","title":"Infixing and sections","text":"<p>Given a function <code>f</code>, one can write it infix (i.e. in between its two arguments):</p> repl example<pre><code>-- treating a prefix function as an infix function\n&gt; let subtract x y = x - y\n&gt; subtract 6 4\n2\n&gt; 6 `subtract` 4\n2\n</code></pre> <p>Functions whose names are symbols, like <code>+</code>, <code>$</code> and <code>.</code>, are written infix by default. An order of precedence is defined, to avoid the need for bracketing. For example, <code>f a . f b</code> means <code>(f a) . (f b)</code>, and similarly, <code>f a $ f b</code> means <code>(f a) $ (f b)</code>. </p> <p>For functions like <code>+</code> or <code>/</code> that are written by default infix, Haskell has some syntactic sugar to convert functions from infix to  prefix (before their arguments):</p> repl example<pre><code>-- treating an infix function as a prefix function\n&gt; 5 / 2\n2.5\n&gt; (/) 5 2 -- (1)!\n2.5\n&gt; (/) 2 5\n0.4\n&gt; (/ 5)  2 -- (2)!\n0.4\n&gt; (5 /)  2\n2.5\n</code></pre> <ol> <li>Whether infix or not, the type of <code>(/)</code> is <code>Double -&gt; (Double -&gt; Double)</code>.</li> <li>This is called a \"section\".</li> </ol>"},{"location":"basics/syntax/#infixing-in-types","title":"Infixing in types","text":"<p>Similarly, <code>-&gt;</code> is a type-level infix operation: <code>a -&gt; b</code> can be written <code>(-&gt;) a b</code>.</p> <p>As this suggests, <code>-&gt;</code> is like <code>Either</code> in that it is a function on types:</p> repl example<pre><code>&gt; :kind (-&gt;)\n(-&gt;) :: * -&gt; (* -&gt; *)\n&gt; :kind (-&gt;) Bool\n(-&gt;) Bool :: * -&gt; *\n&gt; :kind (-&gt;) Bool Bool \n(-&gt;) Bool Bool :: *\n</code></pre>"},{"location":"basics/syntax/#bracketing","title":"Bracketing","text":"<p>Haskell tends to avoid brackets when possible.</p> <p>Expressions like <code>4 * 3 + 5</code> take a default bracketing (given when the operators were defined).</p> <p>Functions application is left-associative: </p> <ul> <li><code>f x y z</code> means <code>((f x) y) z</code></li> <li><code>Either Bool Int</code> means <code>(Either Bool) Int</code></li> </ul> <p>The <code>-&gt;</code> type is right-associative:</p> <ul> <li><code>A -&gt; B -&gt; C -&gt; D</code> means <code>A -&gt; (B -&gt; (C -&gt; D))</code></li> </ul>"},{"location":"basics/syntax/#dollar-sign","title":"Dollar Sign","text":"<p>Code like the following is common in Haskell:</p> <pre><code>exampleWithDollar = not $ (&gt; 3) 4\n</code></pre> <p>This is equivalent to:</p> <pre><code>exampleWithoutDollar = not ( (&gt; 3) 4)\n</code></pre>  <p>Note</p> <p><code>$</code> is just a regular function, used infix, and defined so that <code>f $ x = f x</code>.</p> <p>For more explanation, see: https://typeclasses.com/featured/dollar.</p>  <p>Dollars can be stacked:</p> <pre><code>exampleWithDollar = not $ (&gt; 3) $ head [1,2,3]\n</code></pre> <p>means the same as:</p> <pre><code>exampleWithoutDollar = not ((&gt; 3) (head [1, 2, 3]))\n</code></pre>  <p>Tip</p> <p>Whenever you see a <code>$</code>, read everything to the right as the input to what is on the left.</p>"},{"location":"basics/syntax/#case-of","title":"Case-of","text":"<p>Here is an example of a <code>case _ of</code> statement:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\nimport Data.Text (Text)\n\ndata Color = Black | White\ndata Piece = Bishop Color | Knight Color | King Color\n\npieceToText :: ChessPiece -&gt; Text\npieceToText (Piece _ color) = case color of \n    Black -&gt; \"black\"\n    White -&gt; \"white\"   \n</code></pre> <p>This is a convenient way to pattern match.</p>"},{"location":"basics/syntax/#guards","title":"Guards","text":"<p>These are similar to <code>case</code> statements, but instead of pattern matching, you give a boolean condition:</p> <pre><code>example :: Int -&gt; Bool\nexample x \n    | x &gt; 0 &amp;&amp; x &lt; 10 = True\n    | otherwise = False\n</code></pre>  <p>Note</p> <p><code>otherwise</code> is not a keyword, in fact it is just the value <code>True</code>:</p> repl example<pre><code>&gt; otherwise\nTrue\n&gt; :t otherwise\notherwise :: Bool\n</code></pre> <p>For this reason, <code>otherwise</code> will always satisfy the guard, and so is an appropriate catch-all final line.</p>"},{"location":"basics/syntax/#let-in","title":"Let-in","text":"<pre><code>example :: Int\nexample = \n    let val1 = 5 \n        val2 = val1 + 5\n    in val1 + val2 + 1 \n</code></pre> <p>Let-bindings may be recursive.</p> <pre><code>example :: Int\nexample = \n    let val1 = 0 : val2\n        val2 = 1 : val1\n    in val1\n</code></pre>  <p>Hint</p> <p>This gives an infinite list. You can sample from it as follows:</p> <pre><code>&gt; take 20 example\n[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]\n</code></pre> <p>See the section on laziness for more information.</p>"},{"location":"basics/syntax/#where","title":"Where","text":"<p>Similar to <code>let</code>:</p> <pre><code>example = val1 where\n    val1 = 0 : val2\n    val2 = 1 : val1\n</code></pre> <p>See here for differences .</p>"},{"location":"basics/syntax/#do-notation","title":"Do-notation","text":"<p>Do-notation is a syntax for imperative style programming. It can be used in conjunction with the IO type:</p> <pre><code>example :: IO ()\nexample = do\n  userInput &lt;- getLine\n  let reversed = reverse userInput\n  writeFile \"file/path\" reversed\n  print reversed\n</code></pre> <p>Here, the order of operations is top-down (read line, write file, print), and the <code>&lt;-</code> arrow gives a name to the result of an operation (like <code>userInput</code>, which is the result of reading from stdIn with <code>getLine</code>) which can be used later.</p>  <p>Note</p> <p>Do-notation gets converted in the following way:</p> with dowithout do   <pre><code>do \n    x &lt;- m\n    f x\n</code></pre>   <pre><code>m &gt;&gt;= (\\x -&gt; f x)\n</code></pre>    <p>Or for the above example:</p> with dowithout do   <pre><code>example :: IO ()\nexample = do\n    userInput &lt;- getLine\n    let reversed = reverse userInput\n    writeFile \"file/path\" reversed\n    print reversed\n</code></pre>   <pre><code>example :: IO ()\nexample = getLine &gt;&gt;= (\\userInput -&gt; \n    let reversed = reverse userInput\n    in (writeFile \"file/path\" reversed &gt;&gt;= \n    (\\_ -&gt; print reversed)))\n</code></pre>    <p>As this shows, not only <code>IO</code>, but any type <code>f :: * -&gt; *</code> which is an instance of <code>Monad</code> (and thus implements <code>&gt;&gt;=</code>) can be used with do-notation.  For this reason, do-notation is common in Haskell code with many different <code>Monad</code> instances.</p>"},{"location":"basics/types/","title":"Values and Types","text":""},{"location":"basics/types/#the-type-of-booleans","title":"The type of Booleans","text":"<p><code>True</code> is a value in Haskell. Its type is <code>Bool</code>. In Haskell, we can state this as:</p> In a replIn a file   <pre><code>True :: Bool -- (1)!\n</code></pre> <ol> <li>Read \"X :: Y\" as: \"the value X has the type Y\"</li> </ol>   <pre><code>example :: Bool\nexample = True\n</code></pre>    <p>Similarly, </p> <pre><code>False :: Bool\n</code></pre>  <p>Note</p> <p>In Haskell, everything from simple values like <code>True</code> to complex programs have a unique type. </p>   <p>Tip</p> <p>Haskell types can be quite complex. To understand a type, always ask: what do the values belonging to this type look like?</p> <p>For example, the values belonging to <code>Bool</code> are <code>True</code> and <code>False</code>.</p>"},{"location":"basics/types/#the-type-of-integers","title":"The type of integers","text":"<p><code>Int</code> is a type for integers, as in:</p> <pre><code>5 :: Int\n</code></pre>  Gotcha <p><code>5</code> can have a more general type in Haskell. See here</p>"},{"location":"basics/types/#the-type-of-real-numbers","title":"The type of real numbers","text":"<p>There are several available options. A good general choice is <code>Double</code>:</p> <pre><code>5.0 :: Double\n</code></pre>"},{"location":"basics/types/#the-type-of-text","title":"The type of text","text":"<p><code>Char</code> is the type of single characters:</p> repl example<pre><code>&gt; :t 'a'\n'a' :: Char\n\n&gt; :t 'b'\n'b' :: Char\n</code></pre> <p><code>Text</code> is the type of sequences of characters:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-} --(1)!\nimport Data.Text (Text)\n\nexampleText :: Text \nexampleText = \"hello world!\"\n</code></pre> <ol> <li>See here for why this extension is needed.</li> </ol>"},{"location":"basics/types/#the-type-of-functions","title":"The type of functions","text":"<p>A function in Haskell means the same as a function in mathematics: it takes an input and produces an output. The type of the function depends on the type of the input and the type of the output. </p> In a replIn a file   <pre><code>(\\x -&gt; x &gt; 3) :: (Int -&gt; Bool)\n</code></pre>   <pre><code>exampleFunction = (\\x -&gt; x &gt; 3) :: (Int -&gt; Bool)\n</code></pre>     <p>Note</p> <p>In Python, this would be written: <code>lambda x: x &gt; 3</code></p>  <p>We can also define functions without the lambda syntax, like so:</p> <pre><code>exampleFunction :: Int -&gt; Bool\nexampleFunction x = x &gt; 3\n</code></pre> <p>!! Note     <code>Int</code> and <code>Bool</code> here are parameters of the type <code>Int -&gt; Bool</code>. One can obtain a different type by changing these parameters,  e.g. <code>Text -&gt; Int</code>.</p>"},{"location":"basics/types/#product-types-tuples","title":"Product types (tuples)","text":"<p>Pairs of values are themselves values. For example <code>(True, False)</code> has type <code>(Bool, Bool)</code>:</p> <pre><code>(True, False) :: (Bool, Bool)\n</code></pre>  <p>Note</p> <p><code>(Bool, Bool)</code> is a type defined in terms of another type, <code>Bool</code>. We could change either the left-hand or right-hand type, to get new types, like:</p> <ul> <li><code>(Bool, Int)</code></li> <li><code>(Int, Bool)</code></li> <li><code>((Bool, Int), Bool)</code></li> </ul>"},{"location":"basics/types/#sum-types","title":"Sum types","text":"<p>If you have two types, say <code>Bool</code> and <code>Int</code>, then you can generate a new type which is their disjoint union, called <code>Either Bool Int</code>. </p> <pre><code>(Left True) :: Either Bool Int -- (1)!\n(Left False) :: Either Bool Int \n(Right 3) :: Either Bool Int -- (2)!\n(Right 7) :: Either Bool Int\n</code></pre> <ol> <li> <p><code>Left</code> is a function which takes <code>True</code> as an argument. In other languages, this might be written <code>Left(True)</code></p> </li> <li> <p><code>Right</code> is a function which takes <code>3</code> as an argument. In other languages, this might be written <code>Right(3)</code></p> </li> </ol>  <p>Note</p> <p><code>Left</code> and <code>Right</code> are functions. </p> <pre><code>Left :: Bool -&gt; Either Bool Int --(1)!\nRight :: Int -&gt; Either Bool Int\n</code></pre> <ol> <li>Actually, the type is more general: <code>forall a. a -&gt; Either a Int</code>. See the section on universally quantified types.</li> </ol>"},{"location":"basics/types/#maybe","title":"Maybe","text":"<p>A closely related type is <code>Maybe</code>, which in other languages is sometimes called <code>Optional</code>:</p> Some values and their types<pre><code>Just True :: Maybe Bool -- (1)!\nJust 5 :: Maybe Int\nNothing :: Maybe Bool\n-- Also true:\nNothing :: Maybe Int -- (2)!\n</code></pre> <ol> <li> <p><code>Just</code> is a function of type <code>Bool -&gt; Maybe Bool</code>.</p> </li> <li> <p>The most general type of <code>Nothing</code> is <code>forall a. Maybe a</code>: see the section on Universal types.</p> </li> </ol>"},{"location":"basics/types/#the-unit-type","title":"The unit type","text":"<p>The type <code>()</code> contains a single value, which is also written <code>()</code>.</p>  <p>Note</p> <p>Conceptually, <code>Maybe X</code> is the same as <code>Either () X</code> (for any type <code>X</code>).</p>   <p>Warning</p> <p>This practice of writing a type and a value with the same symbol is known as punning, and is quite widespread in Haskell. Be sure, when reading <code>() :: ()</code>, to understand that the <code>()</code> on the left is a value and the <code>()</code> on the right is a type.</p>"},{"location":"basics/types/#the-empty-type","title":"The empty type","text":"<p><code>Void</code> is the type with no values. It can be useful (mostly as a building block for more complex types), but at an introductory level is fairly rare. </p> <pre><code>example :: Void\nexample = ??? -- (1)!\n</code></pre> <ol> <li>Nothing can go here except something like <code>undefined</code>, which throws a runtime error.</li> </ol>"},{"location":"basics/types/#the-list-type","title":"The list type","text":"<p>The type of a list of <code>Bool</code>s is written <code>[Bool]</code> or <code>[] Bool</code>.</p> <p>The type of a list of <code>Ints</code> is written <code>[Int]</code> or <code>[] Int</code>.</p> <p>More generally, for any type <code>a</code>, <code>[a]</code> is the type of lists of values of type <code>a</code>.</p>  <p>Gotcha</p> <p>Lists are homogeneous: all elements must have the same type.</p>  <p>Write a list as in Python, like <code>[True, False, True]</code>. <code>:</code> is an operator to append to the front of a list. Examples:</p> repl example<pre><code>&gt; 4 : [3, 1]\n[4, 3, 1]\n&gt; 4 : []\n[4]\n&gt; [1..10]\n[1,2,3,4,5,6,7,8,9,10]\n</code></pre>  <p>Note</p> <p><code>[1,2,3]</code> is just convenient syntax for <code>1 : (2 : (3 : []))</code>.</p>"},{"location":"basics/types/#the-io-type","title":"The IO type","text":"<p>The type <code>IO Bool</code> describes a process which can do arbitrary I/O, such as reading and writing to files, starting threads, running shell scripts, etc. The <code>Bool</code> indicates that a result of running this process will be to produce a value of type <code>Bool</code>. More generally, for any type <code>a</code>, <code>IO a</code> runs a process and returns a value of type <code>a</code>. </p> <p>An example:</p> repl example<pre><code>import qualified Data.Text.IO as T\n&gt; :t getLine\nT.getLine :: IO T.Text\n</code></pre> <p>If run, this will read a line from StdIn and this line will be the value of type <code>Text</code> that is produced.</p> <p>The top level function in a Haskell project is often:</p> <pre><code>main :: IO ()\nmain = ...\n</code></pre>"},{"location":"basics/types/#universal-types","title":"Universal types","text":"<p>Here is an example of polymorphism, or universal quantification over types:</p> Quantifiers implicitQuantifiers written   <pre><code>swap :: (a, b) -&gt; (b, a)\nswap (x, y) = (y, x)\n</code></pre>   <pre><code>swap :: forall a b . (a, b) -&gt; (b, a) -- (1)!\nswap (x, y) = (y, x)\n</code></pre> <ol> <li>You'll need the extension <code>ExplicitForAll</code> to enable this.</li> </ol>    <p>Read this type as saying: for any type <code>a</code>, and any type <code>b</code>, this function will take a pair of values, one of type <code>a</code> on the left,  and one of type <code>b</code> on the right, and give back a pair in the other order.</p> <p>Specific types are always uppercase, but a variable ranging over types like <code>a</code> and <code>b</code> above are always lowercase.</p>  <p>Note</p> <p>\"any type\" really means any type. That includes <code>Bool</code>, <code>Int</code>, <code>Text</code>, <code>[Bool]</code>, <code>[(Bool, Int)]</code>, functions like <code>(Int -&gt; Bool)</code> or <code>(Int -&gt; Int) -&gt; Bool</code>, custom types you defined (e.g. <code>ChessPiece</code>), <code>Either Bool [Int]</code>, <code>IO Int</code>, and so on.</p>   <p>Tip</p> <p>Universally quantified types are not like <code>Any</code> in Python. For example, the Boolean negation function <code>not :: Bool -&gt; Bool</code> does not also have the type <code>a -&gt; a</code>.</p> <p>In <code>forall a. (a, b) -&gt; (b, a)</code>, both occurrences of <code>a</code> must be the same, and both occurrences of <code>b</code> must be the same. so <code>(Bool, Int) -&gt; (Int, Bool)</code> or <code>(Text, Double) -&gt; (Double, Text)</code>, but not <code>(Bool, Int) -&gt; (Double, Text)</code>. </p> <p>For this reason, the only function that has type <code>forall a. a -&gt; a</code> is the identity function (written <code>id</code>), because that is the only operation you can be sure works for every input type.</p> <p>And no function has the type <code>forall a b. a -&gt; b</code>, because that function would need to be able to take an input of any type, and return an output of any type.</p>"},{"location":"basics/types/#how-to-use","title":"How to use","text":"<p>If you have a function with a universally quantified type as input, you can always call it on any particular types. For example:</p> repl example<pre><code>&gt; let swap (a,b) = (b,a)\n&gt; swap (4, True)\n(True,4)\n&gt; swap ('a', 3)\n(3,'a')\n</code></pre> <p>If you have a non-function value of a universally quantified type, like undefined <code>:: forall a . a</code> , you may use it as the argument to any function (although actually running the code will throw an error if <code>undefined</code> is evaluated.)</p> repl example<pre><code>&gt; :t not\nnot :: Bool -&gt; Bool\n&gt; :t not undefined\nnot undefined :: Bool\n</code></pre>"},{"location":"basics/types/#usage-with-parametrized-types","title":"Usage with parametrized types","text":"<p>Universally quantified types can appear as the parameters of other types:</p> standardwith explicit quantifiers   <pre><code>getLeft :: Either a b -&gt; Maybe a\ngetLeft (Left x) = Just x\ngetLeft (Right _) = Nothing\n</code></pre>   <pre><code>getLeft :: forall a b. Either a b -&gt; Maybe a\ngetLeft (Left x) = Just x\ngetLeft (Right _) = Nothing\n</code></pre>    <p>The universally quantified <code>a</code> and <code>b</code> indicate that <code>getLeft</code> is only manipulating the structure of the input, but nothing more. For example, if a function like <code>not</code> was called on <code>x</code>, then <code>a</code> could no longer be universally quantified:</p> <pre><code>getLeft :: Either Bool b -&gt; Maybe Bool\ngetLeft (Left x) = Just (not x)\ngetLeft (Right _) = Nothing\n</code></pre>"},{"location":"basics/types/#types-for-types","title":"Types for types","text":"<p>Types themselves have types, sometimes known as kinds. </p> repl example<pre><code>&gt; :kind Bool\nBool :: * -- (1)!\n&gt; :kind Int\nInt :: *\n&gt; :kind (Either Bool Int)\nEither Bool Int :: *\n\n\n&gt; :k Either\nEither :: * -&gt; (* -&gt; *) -- (2)! \n&gt; :k (Either Bool)\nEither Bool :: (* -&gt; *) \n&gt; :k (Either Int)\nEither Int :: (* -&gt; *) \n\n&gt; :k [Bool]\n[Bool] :: *\n&gt; :k (Bool, Int)\n(Bool, Int) :: *\n\n&gt; :k []\n[] :: * -&gt; *\n</code></pre> <ol> <li><code>*</code> is the kind for all types that can have values, like <code>Bool</code>, <code>Either Bool Int</code>, <code>[Bool]</code> and so on.</li> <li>Consult this section if this is unclear. Note also that it will be displayed: <code>* -&gt; * -&gt; *</code> by the repl.</li> </ol>  <p>Note</p> <p>The ability to have types of \"higher kinds\" (i.e. kinds like <code>* -&gt; *</code>, or <code>* -&gt; * -&gt; *</code>) is a central feature that makes Haskell's type system more sophisticated than many languages.</p> <p>In codebases, it is common to encounter types like <code>ReaderT</code> which has kind <code>* -&gt; (* -&gt; *) -&gt; * -&gt; *</code> or <code>Fix</code>, which has kind <code>(* -&gt; *) -&gt; *</code></p>"},{"location":"basics/types/#universal-quantification-for-other-kinds-than","title":"Universal quantification for other kinds than <code>*</code>","text":"<p>Tip</p> <p>Make sure to use the <code>GHC2021</code> extension or add the language extensions recommended by Haskell Language Server for this section.</p>  <p>In a universally quantified type like <code>forall a. a</code>, we can explicitly specify the kind of types that the quantifier <code>forall</code> ranges over:</p> <pre><code>swap :: forall (a :: *) (b :: *) . (a, b) -&gt; (b, a)\nswap (x, y) = (y, x)\n</code></pre> <p>The kind does not need to be <code>*</code>. For example, here is the type of <code>fmap</code> (see this section about typeclasses):</p> With kinds shown explicitlyWithout kinds shown explicitly (standard)   <pre><code>fmap ::forall (f :: * -&gt; *) (a::*) (b::*). Functor f =&gt; (a -&gt; b) -&gt; (f a -&gt; f b)\n</code></pre>   <pre><code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre>"},{"location":"casestudy/chess/","title":"Chess Logic","text":"Chess.hs<pre><code>module Chess where -- (3)!\n\nimport Data.Char (toUpper)\nimport Data.List (intercalate, intersperse)\nimport Data.Text qualified as T\nimport Witch (into)\n\n\ndata PieceType = Bishop | Rook | Knight | Pawn | King | Queen -- (1)!\n  deriving (Eq, Show) -- (4)!\n\ndata Color = Black | White\n  deriving (Eq, Show)\n\ndata Piece = Piece PieceType Color -- (2)!\n  deriving (Eq, Show)\n\ndata File = A | B | C | D | E | F | G | H\n  deriving (Eq, Ord, Show, Enum) -- (5)!\n\ndata Rank = One | Two | Three | Four | Five | Six | Seven | Eight\n  deriving (Eq, Ord, Show, Enum)\n\ndata SquareState where -- (7)!\n  Empty :: SquareState\n  HasPiece :: Piece -&gt; SquareState\n  deriving (Show, Eq)\n\n-- (15)!\nnewtype Board where -- (14)!\n  Board :: (File -&gt; Rank -&gt; SquareState) -&gt; Board\n\ninitBoard :: Board -- (6)!\ninitBoard = Board $ \\f r -&gt; Empty\n\ngetSquare :: Board -&gt; (File, Rank) -&gt; SquareState\ngetSquare (Board board) (f,r) = board f r\n\ndisplay :: Board -&gt; T.Text\ndisplay (Board boardFunc) =\n  into @T.Text $ -- (9)!\n    intercalate \"\\n\" $\n      map (intersperse '|') $\n        group 8 flatBoard\n  where\n\n    -- (10)!\n    flatBoard =\n      [ showSquare (boardFunc file rank)\n        | file &lt;- [A .. H],\n          rank &lt;- [One .. Eight] -- (8)!\n      ]\n\n    showPiece (Piece pieceType color) = letterCase color $ case pieceType of\n      Bishop -&gt; 'b'\n      King -&gt; 'k'\n      Knight -&gt; 'n'\n      Queen -&gt; 'q'\n      Rook -&gt; 'r'\n      Pawn -&gt; 'p'\n\n    showSquare = \\case\n      -- (11)!\n      Empty -&gt; '_'\n      HasPiece p -&gt; showPiece p\n\n    letterCase = \\case\n      Black -&gt; toUpper -- (12)!\n      White -&gt; id -- (13)!\n\n-- helper function: split list into chunks of size n\ngroup :: Int -&gt; [a] -&gt; [[a]]\ngroup _ [] = []\ngroup n l = (take n l) : (group n (drop n l))\n</code></pre> <ol> <li>A sum type.</li> <li>A product type.</li> <li>Module should have same name as file.</li> <li>Automatically derive Eq and Show typeclasses</li> <li><code>Enum</code> allows for writing e.g. <code>[A .. H]</code></li> <li>Alternative approaches include</li> <li>Another syntax for custom datatypes, know as GADT</li> <li>A list comprehension, as in Python.</li> <li><code>into</code> is from the witch package, for type coercions. <code>@Text</code> indicates the type to coerce to.</li> <li>No need to write type signatures (although it's good practice) - Haskell will infer them for you.</li> <li><code>\\case</code> requires the <code>LambdaCase</code> extension which has been globally enabled in the project's <code>.cabal</code> file.</li> <li>If <code>Black</code>, return function to uppercase the character.</li> <li>If <code>White</code>, don't change the letter case. <code>id</code> can be useful.</li> <li><code>newtype</code> is like the <code>data</code> keyword. See more about <code>newtype</code> here</li> <li>Alternative approaches to the <code>Board</code> type include.</li> </ol>"},{"location":"casestudy/chess/#analysis","title":"Analysis","text":"<p>Because custom types are so easily made and expressive, it is typical in Haskell to create types that model your problem domain (here various chess-related types).</p> <p>The central type is <code>Board</code>, which represents the state of a chessboard. We have chosen to directly represent the board's state as a function from a square (specified by file and rank) to the square's state. </p> <p>A good example of type-based refactoring in Haskell is to change <code>Board</code> to an alternative representation and then fix the series of type errors that Haskell will show you in order to make the new <code>Board</code> type work across your project.</p>"},{"location":"casestudy/chess/#alternative-approaches","title":"Alternative approaches","text":""},{"location":"casestudy/chess/#initboard","title":"<code>initBoard</code>","text":"originalwildcardswith <code>curry</code> and <code>const</code>   <pre><code>initBoard :: Board\ninitBoard = Board $ \\f r -&gt; Empty\n</code></pre>   <pre><code>initBoard :: Board\ninitBoard = Board $ \\_ _ -&gt; Empty\n</code></pre>   <pre><code>initBoard :: Board\ninitBoard = Board $ curry $ const Empty\n</code></pre>  <p>Tip</p> <p>To understand how this works, lookup the types of <code>const</code> and <code>curry</code> on Hoogle (both are common and useful functions).</p> <p>Then ascertain the type of <code>const Empty</code> with VSCode, namely:</p> <ul> <li><code>(const Empty) :: (File, Rank) -&gt; SquareState</code></li> </ul> <p>Convince yourself that this is an appropriate input type for <code>curry</code>, and an appropriate output type for <code>const</code>.</p>"},{"location":"casestudy/chess/#board","title":"<code>Board</code>","text":"originalwith dictionary   <pre><code>data SquareState where \n    Empty :: SquareState\n    HasPiece :: Piece -&gt; SquareState\n\nnewtype Board where\n    Board :: (File -&gt; Rank -&gt; SquareState) -&gt; Board\n</code></pre>   <pre><code>import qualified Data.Map as M\ntype Board = M.Map (File, Rank) Piece\n</code></pre>"},{"location":"casestudy/evaluator/","title":"Evaluator","text":"Evaluator.hs<pre><code>module Evaluator where\n\n\nimport Chess ( display, Board(..), SquareState(HasPiece) )\nimport Control.Monad.Except ( MonadError(throwError) )\nimport Control.Monad.State ( MonadState(put, get), gets, modify ) \nimport Data.Text ( Text ) \nimport Parser ( Instruction(..), ChessError(ReplError, Exit) )\n\nevaluate :: (MonadError ChessError m, MonadState Board m) =&gt; \n  Instruction -&gt; m Text\nevaluate instr = case instr of\n  ReplInstruction \"quit\" -&gt; throwError Exit -- (1)!\n  ReplInstruction \"display\" -&gt; gets display -- (2)!\n  Set file rank piece -&gt; do\n    (Board boardFunc) &lt;- get -- (3)!\n    let newBoard =\n          Board -- (4)!\n            ( \\f r -&gt;\n                if f == file &amp;&amp; r == rank\n                  then HasPiece piece\n                  else boardFunc f r\n            )\n    put newBoard -- (5)!\n    return $ display newBoard\n  ReplInstruction _ -&gt; throwError $ ReplError \"no such instruction\"\n</code></pre> <ol> <li>Throw an error of type <code>ChessError</code>. This is what requires the <code>MonadError ChessError</code> constraint.</li> <li><code>gets display</code> is the same as <code>fmap display get</code>: it accesses the state (of type <code>Board</code>), which requires the <code>MonadState Board</code> constraint, and applies <code>display</code> to it, to return a <code>Text</code> value.</li> <li><code>get</code> is the local state. It takes no arguments.</li> <li>Recall that a <code>Board</code> value represents the board as a function from a <code>File</code> and <code>Rank</code> to a square state, so this function is what we need to change, when updating the <code>Board</code>.</li> <li><code>put</code> takes an argument and sets the state to that argument.</li> </ol>"},{"location":"casestudy/evaluator/#analysis","title":"Analysis","text":"<p><code>MonadError</code> and <code>MonadState</code> are typeclasses for types with the ability to throw errors and mutate local state respectively. See the monad transformer library (mtl) for more.</p> <p>With that in mind, read the type signature of <code>evaluate</code> as follows: <code>evaluate</code> is a function that takes an <code>Instruction</code> and returns <code>Text</code>, but with the possibility of throwing an error of type <code>ChessError</code>, and of changing the state (of type <code>Board</code>).</p> <p>We can think of <code>evaluate</code> as taking a synactic description of an <code>Instruction</code> and evaluating it into a result. For example <code>ReplInstruction \"quit\"</code> is a description of an instruction, but <code>throwError Exit</code> is the actually \"program\" that will quit the repl.</p>"},{"location":"casestudy/evaluator/#evaluate","title":"<code>evaluate</code>","text":"originalwith <code>\\case</code>with <code>modify</code> and <code>gets</code>   <pre><code>evaluate :: (MonadError ChessError m, MonadState Board m) =&gt; \n    Instruction -&gt; m Text\nevaluate instr = case instr of\n    ReplInstruction \"quit\" -&gt; throwError Exit\n    ReplInstruction \"display\" -&gt; gets display\n    Set file rank piece -&gt; do\n        (Board boardFunc) &lt;- get\n        let newBoard =\n            Board\n                ( \\f r -&gt;\n                    if f == file &amp;&amp; r == rank\n                    then HasPiece piece\n                    else boardFunc f r\n                )\n        put newBoard\n        return $ display newBoard\n    ReplInstruction _ -&gt; throwError $ ReplError \"no such instruction\"\n</code></pre>   <pre><code>evaluate' :: (MonadError ChessError m, MonadState Board m) =&gt; \n    Instruction -&gt; m Text\nevaluate' = \\case\n    ReplInstruction \"quit\" -&gt; throwError Exit\n    ReplInstruction \"display\" -&gt; gets display\n    Set file rank piece -&gt; do\n        (Board boardFunc) &lt;- get\n        let newBoard =\n            Board\n                ( \\f r -&gt;\n                    if f == file &amp;&amp; r == rank\n                    then HasPiece piece\n                    else boardFunc f r\n                )\n        put newBoard\n        return $ display newBoard\n    ReplInstruction _ -&gt; throwError $ ReplError \"no such instruction\"\n</code></pre>   <pre><code>evaluate :: (MonadError ChessError m, MonadState Board m) =&gt; \n    Instruction -&gt; m Text\nevaluate instr = case instr of\n    ReplInstruction \"quit\" -&gt; throwError Exit\n    ReplInstruction \"display\" -&gt; gets display\n    Set file rank piece -&gt; do\n        let updateBoard (Board boardFunc) = Board ( \\f r -&gt;\n            if f == file &amp;&amp; r == rank\n                then HasPiece piece\n                else boardFunc f r)\n        modify updateBoard\n        gets display\n    ReplInstruction _ -&gt; throwError $ ReplError \"no such instruction\"\n</code></pre>"},{"location":"casestudy/json/","title":"Json","text":"JSON.hs"},{"location":"casestudy/overview/","title":"Overview","text":"<p>This section is a walkthrough of a project with the code intended to display how to write a simple but real-world application in Haskell.</p> <p>The subsections are ordered by difficulty.</p> <p>The code is written for the compiler version GHC 9.2.5. Getting set up is easy!</p>  <p>Tip</p> <p>We strongly encourage reading Haskell code in a text editor with the IDE activated: mousing over variables will show their type and where they are defined, which is especially helpful when learning. Cmd + <code>click</code> to jump to a definition.</p>"},{"location":"casestudy/overview/#demo","title":"Demo:","text":"<pre><code>cabal run chess-repl \n\nWelcome!\n\n\n&gt; \nplace a white bishop on a5\n_|_|_|_|b|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n&gt; \nplace a black castle on b6\n1:15:\n  |\n1 | place a black castle on b6\n  |               ^^^^^^\nunexpected \"castle\"\nexpecting \"bishop\", \"king\", \"knight\", \"pawn\", \"queen\", \"rook\", or white space\n\n&gt; \n:d\n_|_|_|_|b|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n_|_|_|_|_|_|_|_\n&gt; \n:q\n</code></pre>  <p>Tip</p> <p>If you encounter an expression in this codebase that you don't understand, use Haskell's purity and immutability to your advantage: you can't always break it down into its parts and understand them separately.</p> complicated looking example<pre><code>main :: IO ()\nmain = runInputT defaultSettings $ flip evalStateT initBoard $ forever $ do\n    line &lt;- lift requestLine \n    ...\n</code></pre> <p>Break this down by replacing everything after the first or second dollar sign with <code>undefined</code>, and then mouse over <code>undefined</code> to understand its type:</p> simpler<pre><code>main :: IO ()\nmain = runInputT defaultSettings undefined\n</code></pre> <p>Or </p> simpler<pre><code>main :: IO ()\nmain = runInputT defaultSettings $ flip evalStateT initBoard $ undefined\n</code></pre> <p>Or remove everything before the first or second dollar sign and have Haskell infer the type:</p> simpler<pre><code>-- main :: IO () -- commented out since the type might be different now\nmain = flip evalStateT initBoard $ forever $ do\n    line &lt;- lift requestLine \n    ...\n</code></pre> <p>Consider this the Haskell debugging analogue of inserting print statements.</p>"},{"location":"casestudy/parser/","title":"Parsing","text":"<p>Tip</p> <p>Understanding parser combinators is a prerequisite for this module. See here for information.</p>  Parser.hs<pre><code>module Parser where\n\nimport Chess\n  ( Color (Black, White),\n    File (..),\n    Piece (..),\n    PieceType (..),\n    Rank (..),\n  ) -- (13)!\nimport Control.Applicative (asum, optional)\nimport Data.Char (digitToInt, isDigit)\nimport Data.Text (Text)\nimport Data.Text qualified as T\nimport Data.Void (Void)\nimport Text.Megaparsec\nimport Text.Megaparsec.Char (char, space)\nimport Text.Megaparsec.Char.Lexer (lexeme)\nimport qualified Data.Map as M -- (14)!\nimport Witch (into)\n\ntype Parser = Parsec Void T.Text -- (15)!\n\ndata ChessError = ReplError Text | ParseError Text | Exit deriving Show -- (1)!\n\n-- the result of the parser will be a value of this type\ndata Instruction where\n  Set :: File -&gt; Rank -&gt; Piece -&gt; Instruction\n  ReplInstruction :: Text -&gt; Instruction\n  deriving (Show)\n\n-- run the parser\nparse :: Text -&gt; Either ChessError Instruction\nparse line =\n  either -- (3)!\n    (Left . ParseError . into @Text . errorBundlePretty)\n    Right\n    (runParser parser \"\" line)\n\n-- the parser\nparser :: Parser Instruction\nparser =\n  let replCommand (name, instr) = -- (9)!\n        const (ReplInstruction instr) &lt;$&gt; name -- (4) (8)\n   in asum -- (2)!\n        [ replCommand (\":q\", \"quit\"),\n          replCommand (\":r\", \"reset\"),\n          replCommand (\":d\", \"display\"),\n          place\n        ] -- (5)!\n  where\n\n    -- place (a) white bishop on a4\n    place :: Parser Instruction -- (6)!\n    place = do -- (12)!\n      word \"place\" -- (7)!\n      optional $ word \"a\"\n      piece &lt;- parsePiece\n      word \"on\"\n      file &lt;- asum $ parseFile &lt;$&gt; [A .. H] \n      rank &lt;- asum $ parseRank &lt;$&gt; [One .. Eight]\n      eof -- (10)!\n      return $ Set file rank piece -- (11)!\n\n-- a helper function to add trailing whitespace to a parser\nword :: Parser b -&gt; Parser b\nword = lexeme (\" \" &gt;&gt; space)\n\nparsePiece :: Parser Piece\nparsePiece = do\n  color &lt;- word $ (const White &lt;$&gt; \"white\") &lt;|&gt; (const Black &lt;$&gt; \"black\")\n  pieceType &lt;-\n    word $\n      try (const Bishop &lt;$&gt; \"bishop\")\n        &lt;|&gt; try (const King &lt;$&gt; \"king\")\n        &lt;|&gt; try (const Queen &lt;$&gt; \"queen\")\n        &lt;|&gt; try (const Knight &lt;$&gt; \"knight\")\n        &lt;|&gt; try (const Rook &lt;$&gt; \"rook\")\n        &lt;|&gt; try (const Pawn &lt;$&gt; \"pawn\")\n  return (Piece pieceType color)\n\n-- given a Rank, produce a parser that only recognizes that rank\nparseRank :: Rank -&gt; Parser Rank\nparseRank x =\n  const x\n    &lt;$&gt; char\n      ( case x of\n          One -&gt; '1'\n          Two -&gt; '2'\n          Three -&gt; '3'\n          Four -&gt; '4'\n          Five -&gt; '5'\n          Six -&gt; '6'\n          Seven -&gt; '7'\n          Eight -&gt; '8'\n      )\n\n-- given a File, produce a parser that only recognizes that file\nparseFile :: File -&gt; Parser File\nparseFile x =\n  const x\n    &lt;$&gt; char\n      ( case x of\n          A -&gt; 'a'\n          B -&gt; 'b'\n          C -&gt; 'c'\n          D -&gt; 'd'\n          E -&gt; 'e'\n          F -&gt; 'f'\n          G -&gt; 'g'\n          H -&gt; 'h'\n      )\n</code></pre> <ol> <li>It's often useful to make a custom type for errors specific to the domain in question.</li> <li><code>asum</code> comes from the <code>Alternative</code> typeclass: <code>asum [x,y,z]</code> = <code>x &lt;|&gt; y &lt;|&gt; z</code>.</li> <li><code>either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c</code> is a useful function for handling an <code>Either X Y</code>.</li> <li>Viewed with the Haskell Language Server, this will be underlined in blue, with a simplification suggested.</li> <li>Like anything else in Haskell, parsers are just values, so it's possible (and idiomatic) to put them in a list and then fold the list.</li> <li>Observe how the parser as a whole is built out of smaller parsers.</li> <li><code>\"place\"</code> is itself a parser, thanks to OverloadedStrings.</li> <li><code>a &lt;$&gt; b = fmap a b</code>. That is: <code>&lt;$&gt;</code> is an infix synonym for <code>fmap</code>. Example with <code>const</code>: <code>fmap (const 1) [1,2,3,4] = [1,1,1,1]</code></li> <li>We abstract some boilerplate with a function that makes a simple parser given a name and return value.</li> <li><code>eof</code> only succeeds at the end of a line, so ensures there are no more characters left.</li> <li><code>return</code> is not a keyword. Here, it converts an <code>Instruction</code> into a <code>Parser Instruction</code>, namely the trivial parser that does nothing and immediately returns an <code>Instruction</code>. This <code>Parser Instruction</code> is the final parser in the sequence of parsers in the <code>do-notation</code> code block.</li> <li>do-notation used to build a complex parser out of a series of simpler ones and their results.</li> <li>Explicit imports like this are useful both for readability and to avoid namespace clashes.</li> <li>Another way to avoid namespace clashes. Common for both <code>Data.Map</code> and <code>Data.Text</code>.</li> <li>Void is the empty type. This says that the custom error type is <code>Void</code> (i.e. doesn't exist), and that the type of the input sequence is <code>Text</code>.</li> </ol>"},{"location":"casestudy/parser/#analysis","title":"Analysis","text":"<p>This module exists to parse user input on the command line into the <code>Instruction</code> type. Parsing directly into a custom type is idiomatic Haskell because it handles errors nicely: either parsing succeeds and you're guaranteed to get an <code>Instruction</code>, or you get an interpretable parse failure.</p> <p>Note the use of <code>word</code>, a function which takes a parser and returns a new parser that handles white space. This abstracts white space handling to a single function, and makes for clean, idiomatic parsing.</p>"},{"location":"casestudy/parser/#parsepiece","title":"<code>parsePiece</code>","text":"originalabstractedUsing <code>&lt;$</code>   <pre><code>parsePiece :: Ord a =&gt; Parsec a Text Piece\nparsePiece = do\ncolor &lt;- word $ (const White &lt;$&gt; \"white\") &lt;|&gt; (const Black &lt;$&gt; \"black\")\npieceType &lt;-\n    word $\n    try (const Bishop &lt;$&gt; \"bishop\")\n        &lt;|&gt; try (const King &lt;$&gt; \"king\")\n        &lt;|&gt; try (const Queen &lt;$&gt; \"queen\")\n        &lt;|&gt; try (const Knight &lt;$&gt; \"knight\")\n        &lt;|&gt; try (const Rook &lt;$&gt; \"rook\")\n        &lt;|&gt; try (const Pawn &lt;$&gt; \"pawn\")\nreturn (Piece pieceType color)\n</code></pre>   <pre><code>parsePiece :: Ord a =&gt; Parsec a Text Piece\nparsePiece = do\ncolor &lt;- word $ (const White &lt;$&gt; \"white\") &lt;|&gt; (const Black &lt;$&gt; \"black\")\npieceType &lt;-\n    word $ asum\n    [try (const piece &lt;$&gt; \"bishop\") | piece &lt;- \n        [Bishop, King, Queen, Knight, Rook, Pawn]]\nreturn (Piece pieceType color)\n</code></pre>   <pre><code>parsePiece :: Ord a =&gt; Parsec a Text Piece\nparsePiece = do\ncolor &lt;- word $ ( White &lt;$ \"white\") &lt;|&gt; ( Black &lt;$ \"black\")\npieceType &lt;-\n    word $ asum\n    [try ( piece &lt;$ \"bishop\") | piece &lt;- \n        [Bishop, King, Queen, Knight, Rook, Pawn]]\nreturn (Piece pieceType color)\n</code></pre>"},{"location":"casestudy/parser/#parserank","title":"<code>parseRank</code>","text":"originalwith a <code>Map</code>   <pre><code>parseRank :: Rank -&gt; Parser Rank\nparseRank x =\nconst x\n    &lt;$&gt; char\n    ( case x of\n        One -&gt; '1'\n        Two -&gt; '2'\n        Three -&gt; '3'\n        Four -&gt; '4'\n        Five -&gt; '5'\n        Six -&gt; '6'\n        Seven -&gt; '7'\n        Eight -&gt; '8'\n    )\n</code></pre>   <pre><code>import qualified Data.Map as M\n\nparseRank :: Rank -&gt; Parser Rank\nparseRank x =  const x &lt;$&gt;\ncase x `M.lookup` M.fromList (zip [One .. Eight] ['1'..'8']) of\n    Just c -&gt; char c\n    Nothing -&gt; error \"unreachable state\"\n</code></pre>"},{"location":"casestudy/repl/","title":"REPL","text":"Repl.hs<pre><code>{-# LANGUAGE BlockArguments #-} -- (1)!\n\nmodule Repl where\n\nimport Chess\nimport Control.Monad\nimport Control.Monad.Except\nimport Control.Monad.State\nimport Data.Text (Text)\nimport Data.Text qualified as T\nimport Evaluator\nimport Parser\nimport Text.Megaparsec hiding (parse) -- (7)!\nimport Witch (into)\n\n\nmain :: IO ()\nmain = do\n    runReplWithBoard $\n      displayLine \"Welcome!\\n\\n\" &gt;&gt; forever do -- (3)!\n\n        line &lt;- requestLine \"&gt; \" -- (4)!\n        let instruction = parse line -- (5)!\n        board &lt;- get -- (6)!\n        result &lt;-\n          case instruction of\n            Left (ParseError err) -&gt; pure err -- (8)!\n            Left (ReplError err) -&gt; pure err\n            Right instr -&gt; evaluate instr\n              `catchError` ( \\case -- (9)!\n                              ReplError txt -&gt; pure txt\n                              err -&gt; throwError err -- (11)!\n                          )\n\n        displayLine result -- (10)!\n    pure ()\n\n  where\n\n    runReplWithBoard :: StateT Board (ExceptT e IO) a -&gt; IO (Either e a) -- (12)!\n    runReplWithBoard = runExceptT . flip evalStateT initBoard -- (13)!\n\n    displayLine :: Text -&gt; StateT Board (ExceptT ChessError IO) ()\n    displayLine = liftIO . putStrLn . into @String -- (14)!\n\n    requestLine :: Text -&gt; StateT Board (ExceptT ChessError IO) Text\n    requestLine prompt = do\n      displayLine prompt\n      line &lt;- liftIO getLine\n      pure $ into @Text line\n</code></pre> <ol> <li>Allows writing e.g. <code>functionOf do ...</code> instead of <code>functionOf $ do</code>.</li> <li><code>void</code> is a convenient function, which turns <code>IO a</code> to <code>IO ()</code>. Used here because we don't care about the output of the repl, and in fact that output is never reached, because the repl runs a loop indefinitely.</li> <li><code>forever</code> takes a value of type <code>m X</code> (where <code>m</code> has a <code>Monad</code> constraint on it) and loops it: <code>forever mX = mX &gt;&gt; forever mX</code>. It's a clean way to write a for-loop.</li> <li>Get a line from the user.</li> <li>Parse the user's input, using <code>parse</code> from the <code>Parser</code> module.</li> <li>Get the current state of the board.</li> <li><code>hiding</code> is convenient for avoiding namespace conflicts.</li> <li><code>pure</code> is like <code>return</code>, but only requires the <code>Applicative</code> typeclass. It can be used almost everywhere that <code>return</code> is used, but is strictly more general, because a <code>Monad</code> constraint implies an <code>Applicative</code> constraint.</li> <li><code>catchError</code>, here used in infix form, stops an error percolating to the top level. This is useful here, because an uncaught error would halt <code>main</code>, and so exit the repl.</li> <li>Neither <code>return</code> nor <code>pure</code> is a keyword, and a block of <code>do-notation</code> does not need to end with it. All that is needed at the end of the \"do-block\" is a value of type <code>m a</code> (for the monad <code>m</code> in question), and <code>displayLine result</code> has that type.</li> <li><code>catchError</code> chooses what to do with the error it catches, and one option is to throw it again. It does this for errors including <code>Exit</code>, in order to exit the repl on \":q\".</li> <li><code>runReplWithBoard</code> is the function responsible for \"unpacking\" the monadic value into something simpler. This is sometimes referred to as \"running the side effects\" of a program.</li> <li><code>flip</code> is a useful function that takes a function of type <code>X -&gt; Y -&gt; Z</code> and flips the argument order to give a function of type <code>Y -&gt; X -&gt; Z</code>. It is often useful when writing in pointfree style.</li> <li>It is often useful to lift the type <code>IO X</code> to the more abstract <code>MonadIO m =&gt; m X</code>, which is what <code>liftIO</code> does.</li> </ol>"},{"location":"casestudy/repl/#analysis","title":"Analysis","text":"<p>This module is responsible for producing the actual runnable program (of type <code>IO ()</code>) that wraps up the whole system.</p>"},{"location":"casestudy/repl/#main","title":"<code>main</code>","text":"original   <p>```haskell</p>    <p>main :: IO ()     main =         void $              runReplWithBoard $             displayLine \"Welcome!\\n\\n\" &gt;&gt; forever do</p> <pre><code>            line &lt;- requestLine \"&gt; \"\n            let instruction = parse line\n            board &lt;- get\n            result &lt;-\n            case instruction of\n                Left (ParseError err) -&gt; pure err\n                Left (ReplError err) -&gt; pure err\n                Right instr -&gt; evaluate instr\n                `catchError` ( \\case\n                                ReplError txt -&gt; pure txt\n                                err -&gt; throwError err \n                            )\n\n            displayLine result \n```\n</code></pre> without <code>forever</code>   <p>```haskell</p>    <p>main :: IO ()     main =         runReplWithBoard $         displayLine \"Welcome!\\n\\n\" &gt;&gt; loop where </p> <pre><code>        loop = do\n\n        line &lt;- requestLine \"&gt; \"\n        let instruction = parse line\n        board &lt;- get\n        result &lt;-\n            case instruction of\n            Left (ParseError err) -&gt; pure err\n            Left (ReplError err) -&gt; pure err\n            Right instr -&gt; evaluate instr\n                `catchError` ( \\case\n                                ReplError txt -&gt; pure txt\n                                err -&gt; throwError err \n                            )\n\n        displayLine result \n        loop\n```\n</code></pre> without <code>void</code>   <p>```haskell</p>    <p>main :: IO ()     main = do         runReplWithBoard $             displayLine \"Welcome!\\n\\n\" &gt;&gt; forever do</p> <pre><code>            line &lt;- requestLine \"&gt; \"\n            let instruction = parse line\n            board &lt;- get\n            result &lt;-\n            case instruction of\n                Left (ParseError err) -&gt; pure err\n                Left (ReplError err) -&gt; pure err\n                Right instr -&gt; evaluate instr\n                `catchError` ( \\case\n                                ReplError txt -&gt; pure txt\n                                err -&gt; throwError err \n                            )\n\n            displayLine result \n    pure ()\n```\n</code></pre>"},{"location":"casestudy/tests/","title":"Tests","text":"Tests.hs<pre><code>module Main where\n\nimport Chess\nimport Control.Monad (void)\nimport Debug.Trace (traceM)\nimport System.Exit (exitFailure)\nimport Test.Hspec\nimport Test.QuickCheck (Arbitrary, Testable (property), choose, chooseEnum)\nimport Test.QuickCheck.Arbitrary (arbitrary)\nimport Test.QuickCheck.Exception (evaluate)\n\n\nmain :: IO ()\nmain = hspec $ do\n  describe \"Chess\" $ do\n\n    -- a unit test\n    it \"a4 should be empty on the starting board\" $ do\n      getSquare initBoard (A, Four) `shouldBe` Empty\n\n    -- a property test (1)\n    it \"any square you pick should be empty, for the starting board\" $\n      property $\n        \\x -&gt; getSquare initBoard x `shouldBe` Empty\n\n-- (2)!\ninstance Arbitrary File where\n  arbitrary = chooseEnum (A, H)\n\ninstance Arbitrary Rank where\n  arbitrary = chooseEnum (One, Eight)\n</code></pre> <ol> <li>See more about property tests here</li> <li>These instances are used by the property tests. They say how to generate a random <code>Rank</code> and <code>File</code>. </li> </ol>"},{"location":"faqs/convertingnumbers/","title":"Coercions","text":"<p>\"I have a <code>Float</code> but want a <code>Double</code>\". Or: I have a <code>String</code> but want a <code>Text</code>.</p>"},{"location":"faqs/convertingnumbers/#answer","title":"Answer","text":"<p>Usually one can find the right function via Hoogle:</p>  <p>However, a more convenient option is to use the <code>Witch</code> library, which abstracts coercions using a single function, called <code>into</code>:</p> <pre><code>{-# LANGUAGE TypeApplications #-} -- (1)!\n\nimport Witch -- (2)!\n\n\nfloat :: Float\nfloat = 4\n\ndouble :: Double\ndouble = into @Double float -- (3)!\n\nstr :: String\nstr = \"hello\"\n\ntext :: Text\ntext = into @Text str\n</code></pre> <ol> <li> <p>Only needed if you aren't using GHC2021.</p> </li> <li> <p>This is a library for performing coercions.</p> </li> <li> <p>The use of the <code>@Double</code> here directs helps the type checker infer the output type of <code>into</code>. Only needed if you don't supply the type signature <code>double :: Double</code>.</p> </li> </ol>"},{"location":"faqs/debugging/","title":"Debugging","text":"<p>How do I debug, since <code>print</code> statements change the type?</p> <p>Because Haskell is pure and functional, the approach of debugging by adding <code>print</code> statements is not needed as often. Instead, you can inspect the subcomponents of your program and their types in isolation, and check their behavior in the repl. </p> <p>However, when you do need <code>print</code> statements, you can use <code>trace</code> from <code>Debug.Trace</code>, like so:</p> repl example<pre><code>&gt; import Debug.Trace (trace)\n&gt; let output = take 10 [1..] in trace ((\"Length: \" &lt;&gt; show (length output))) output\nLength: 10\n[1,2,3,4,5,6,7,8,9,10]\n</code></pre>"},{"location":"faqs/dependentOutput/","title":"Output depends on input","text":"<p>How can I write a function which returns one type sometimes and another type other times?</p> <p>The key is to use <code>Either</code>. For example, suppose you want to write a function that returns the square of a number if the number is positive, but otherwise an error message text. Do this:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Text (Text)\n\nsquareWithFailure :: Int -&gt; Either Text Int --(1)!\nsquareWithFailure i \n    | i &gt;= 0 = Right (i ^ 2)\n    | otherwise = Left \"squareWithFailure only takes non-negative input\"\n</code></pre> <ol> <li>It is conventional for a type representing a failure to go on the left side of an <code>Either</code>.</li> </ol>"},{"location":"faqs/dollar/","title":"Dollar sign","text":"<p>Why is Haskell code full of <code>$</code> signs?</p> <pre><code>someFunction $ anotherFunction $ aThirdFunction argument\n</code></pre>"},{"location":"faqs/dollar/#answer","title":"Answer","text":"<p>Read this as:</p> <pre><code>someFunction (anotherFunction (aThirdFunction argument))\n</code></pre> <p>In other words, everything to the right of any <code>$</code> is the argument of everything to the left.</p> <p>It is popular as a way to avoid excessive brackets. See here for more. See also this Stack Overflow question.</p>"},{"location":"faqs/functionFunctor/","title":"fmap with a function","text":"<p>What is this code doing?</p> repl example<pre><code>&gt; func = fmap not (\\x -&gt; x &gt; 3) \n&gt; func 2\nTrue\n&gt; func 4 \nFalse\n</code></pre>"},{"location":"faqs/functionFunctor/#answer","title":"Answer","text":"<p><code>fmap</code> is the method of the Functor typeclass.</p> <p>To understand what <code>fmap</code> does whenever it is called, it is necessary to know which instance of <code>fmap</code> is being used. You can find this out by mousing over <code>fmap</code> (first place the line <code>func = fmap not (\\x -&gt; x &gt; 3)</code> in a Haskell file in your project), to see:</p>  <p>The line <code>$dFunctor :: Functor ((-&gt;) Integer)</code> means that the instance of <code>Functor</code> being used is <code>((-&gt;) Integer)</code>.</p>  <p>Tip</p> <p>If it is unclear what <code>((-&gt;) Integer)</code> means, see here and here.</p>  <p>The instance of <code>Functor</code> for <code>((-&gt;) Integer)</code> is:</p> <pre><code>instance Functor ((-&gt;) r) where\n    fmap f g = f . g -- (1)! \n</code></pre> <ol> <li>Or in pointfree style: fmap = (.)</li> </ol> <p>and this is what is being used in the examples above.</p>"},{"location":"faqs/io/","title":"I/O","text":"<p>How do I run code with side effects in Haskell, like printing or reading lines?</p>"},{"location":"faqs/io/#answer","title":"Answer","text":"<p>There is a special type, <code>IO ()</code>, for this kind of general side effects like printing, and these actions can be sequenced using the do syntax:</p> <pre><code>import qualified Data.Text as T\n\nexample = IO ()\nexample = do\n    print \"Welcome\"\n    line &lt;- T.getLine\n    let result = someComplexFunction line\n    print result\n</code></pre>"},{"location":"faqs/multipleArguments/","title":"Multiple Arguments","text":"<p>How do I give multiple arguments (i.e. inputs) to a function?</p>"},{"location":"faqs/multipleArguments/#answer","title":"Answer","text":"<p>In a literal sense, functions only take a single argument. However, this argument can be a tuple. </p> <pre><code>multipleArgsFunc :: (Int, Int) -&gt; Int\nmultipleArgsFunc (i,j) = i + j \n</code></pre> <p>Or, the argument can be one of the inputs, and the return value can be a function which takes the next argument:</p> <pre><code>multipleArgsFunc :: Int -&gt; (Int -&gt; Int)\nmultipleArgsFunc = \\i -&gt; (\\j -&gt; (i + j))\n</code></pre> <p>Equivalently, but more idiomatically:</p> <pre><code>multipleArgsFunc :: Int -&gt; (Int -&gt; Int)\nmultipleArgsFunc i j = i + j\n</code></pre> <p>More details here</p>  <p>Summary</p> <p>Instead of giving multiple arguments, give a single argument with multiple parts.</p>"},{"location":"faqs/newtype/","title":"Newtype","text":"<p>What is the difference between <code>newtype</code> and <code>data</code>, when declaring a type?</p> <p>See this Stack Overflow answer.</p>"},{"location":"faqs/numbers/","title":"Converting Numbers","text":"<p>What does the type of number literals mean, e.g. <code>5 :: Num a =&gt; a</code> (or more verbosely: <code>5 :: forall a. Num a =&gt; a</code>)?</p> <p>Read <code>n :: Num a =&gt; a</code> as saying: <code>n</code> has any type whatsoever, as long as that type is an instance of the <code>Num</code> typeclass.</p> <p>Haskell has a typeclass <code>Num</code> for numbers which generalized across various concrete number types like <code>Double</code>, <code>Float</code>, <code>Int</code> and <code>Integer</code>.</p> <p>Haskell will always give the most general typeclass that supports the numeric operations you are using:</p> repl example<pre><code>&gt; :t 5 + 3\n5 + 3 :: Num a =&gt; a -- (1)!\n\n&gt; :t 5 / 3\n5 / 3 :: Fractional a =&gt; a -- (2)!\n\n&gt; :t 5 ** 3\n5 ** 3 :: Floating a =&gt; a -- (3)!\n</code></pre> <ol> <li><code>(+)</code> is an operation supported by the <code>Num</code> typeclass.</li> <li><code>(/)</code> is an operation supported by <code>Fractional</code>, a class that inherits from <code>Num</code></li> <li><code>(**)</code> is an operation supported by <code>Floating</code>, a class that inherits from <code>Num</code></li> </ol> <p>Like all universally quantified values, a value of type <code>forall a. Num a =&gt; a</code> can be given as input to any function that takes an concrete number type:</p> repl example<pre><code>&gt; n = 5\n&gt; :t n\nn :: Num a =&gt; a\n&gt; double = (\\x -&gt; x + x) :: Double -&gt; Double\n&gt; double n\n10\n</code></pre>"},{"location":"faqs/optionalArguments/","title":"Optional Arguments","text":"<p>How do I give optional arguments (i.e. inputs) to a function? For example, in</p> <pre><code>shiftByFour :: Bool -&gt; Int -&gt; Int\nshiftByFour flag x = if flag then x + 4 else x - 4\n</code></pre> <p>I want the <code>Bool</code> flag to be optional, and to have a default value.</p>"},{"location":"faqs/optionalArguments/#answer","title":"Answer","text":"<p>In a literal sense, you cannot have an optional argument. </p> <p>The way to do this is to make a function take a <code>Maybe Bool</code> instead of a <code>Bool</code>. For example:</p> <pre><code>shiftByFour maybeFlag x = case maybeFlag of \n    Nothing -&gt; supply-some-default-behavior\n    Just flag -&gt; if flag then x + 4 else x - 4\n</code></pre>  <p>Summary</p> <p>Instead of optionally having an argument, have a non-optional argument which has an optional type.</p>"},{"location":"faqs/speed/","title":"Speed","text":"<p>Is Haskell fast?</p>"},{"location":"gettingstarted/example/","title":"Example Haskell File","text":"<p>An example Haskell file. This defines a module which can be imported by other modules in project.</p> <pre><code>{-# LANGUAGE GADTs #-} -- (1)!\n\nmodule Chess where -- (2)!\n\n\n-- (3)!\ndata Piece where \n    Bishop :: Piece\n    Rook   :: Piece\n\nisBishop :: Piece -&gt; Bool\nisBishop Bishop = True\nisBishop _ = False\n</code></pre> <ol> <li>Language extensions go here.</li> <li>Module name must match the file name.</li> <li>Code goes here and below.</li> </ol>"},{"location":"gettingstarted/overview/","title":"Quick start","text":"<p>Getting set up with Haskell is very easy, here is the recommended route:</p>"},{"location":"gettingstarted/overview/#step-1-installation","title":"Step 1 (installation)","text":"<p>Run the Haskell installer, GHCup, using the instructions on that page.</p> <p>To check that this was successful, enter the comand <code>ghci</code> into your terminal. This will open a Haskell REPL where you can execute Haskell code (much like in Python).  To exit GHCi, type <code>:q</code> at the prompt.</p>"},{"location":"gettingstarted/overview/#step-2-make-a-project","title":"Step 2 (make a project)","text":"<p>The REPL is useful for evaluating simple expressions and in-project debugging, but we recommend setting up a project as a first step to learning Haskell.</p> <p>In a new directory of your choice, create a new Haskell project by running:</p> <pre><code>cabal init --interactive\n</code></pre> <p>or if you prefer, clone the repository from these very docs, which is itself a Haskell project.</p> <p>This will create a file ending in the suffix <code>.cabal</code>, which is where you will specify package requirements and other build details. For instance:</p> <pre><code>cabal-version:      2.4\nname:               haskell-book\nversion:            0.1.0.0\nmaintainer:         reubenharry@gmail.com\n\nextra-source-files:\n    CHANGELOG.md\n    README.md\n\nlibrary\n    exposed-modules:  MyLib\n\n    build-depends:    \n        base ^&gt;=4.16.3.0,\n        text\n    hs-source-dirs:   src\n    default-language: Haskell2010\n\nexecutable haskell-book\n    main-is:          Main.hs\n    build-depends:\n        base ^&gt;=4.16.3.0,\n        haskell-book\n\n    hs-source-dirs:   app\n    default-language: Haskell2010\n</code></pre> <p>This package contains both a library and an executable.  To run the functions in the library, first enter the Haskell REPL from the root of the project directory (where the <code>.cabal</code> file is):</p> <pre><code>cabal repl\n</code></pre> <p>And then do:</p> <pre><code>&gt; import MyLib\n&gt; someFunc\n</code></pre> <p>To build and run the executable:</p> <pre><code>cabal run haskell-book\n</code></pre> <p>You can also build the executable without running it, which is useful for checking if you have compile errors or warnings:</p> <pre><code>cabal build\n</code></pre> <p>Because the <code>haskell-book</code> section of the cabal file gives a source directory of <code>app</code> and a main source file of <code>Main.hs</code>, this will run the variable called <code>main</code> in <code>app/Main.hs</code>.</p>"},{"location":"gettingstarted/overview/#step-3-set-up-the-haskell-language-server","title":"Step 3 (set up the Haskell Language Server)","text":"<p>We highly recommend using the Haskell Language Server. This is an IDE which runs in VSCode (and other platforms).</p> <p>In VSCode, activate it by installing the Haskell extension:</p>  <p>This will make learning Haskell much smoother, by continuously checking your program, underlining type errors, showing inferred types by mouse-over, adding type signatures automatically, adding language extensions and imports when needed, and linting and formatting.</p>"},{"location":"gettingstarted/overview/#step-4-hoogle","title":"Step 4 (Hoogle)","text":"<p>Hoogle is a search engine for Haskell, where you can look up by type. This is accessible at this site, but we recommend installing the <code>hoogle-vscode</code> extension. </p> <p>Open with Option h, and use like so:</p>"},{"location":"gettingstarted/versions/","title":"Configuration","text":""},{"location":"gettingstarted/versions/#managing-software","title":"Managing software","text":"<p>To change your version of GHC, cabal, or the Haskell Language Server:</p> <pre><code>&gt; ghcup tui\n</code></pre> <p>You should see something like:</p>  <p>This makes it easy to change version of the compiler, the Haskell language server, and cabal (the package manager).</p>  Stack <p><code>stack</code> is (roughly) an alternative package manager. Either <code>cabal</code> or <code>stack</code> work well, but this documentation defaults to <code>cabal</code>.</p>"},{"location":"gettingstarted/versions/#installing-packages","title":"Installing packages","text":"<p>To add packages, include their names to the package list in your <code>.cabal</code> file:</p> <pre><code>library\n    exposed-modules:  MyLib\n\n    build-depends:    \n        base ^&gt;=4.16.3.0,\n        text,\n        NEW PACKAGE,\n        ANOTHER NEW PACKAGE\n    hs-source-dirs:   src\n    default-language: GHC2021\n</code></pre> <p>Packages are hosted here, but you can find out more about what packages to use for what here.</p>"},{"location":"gettingstarted/versions/#extensions","title":"Extensions","text":"<p>Haskell allows new code features to be enabled/disabled with lines like:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\n</code></pre> <p>at the top of files. </p> <p>We recommend setting the default-language to <code>GHC2021</code>, which enables a set of compatible and standard extensions. </p>  <p>Warning</p> <p><code>GHC2021</code> will only work for GHC 9 and greater. Otherwise replace with <code>Haskell2010</code>.</p>  <pre><code>library\n    exposed-modules:  MyLib\n\n    build-depends:    \n        base ^&gt;=4.16.3.0,\n        text,\n    hs-source-dirs:   src\n    default-language: GHC2021\n</code></pre>"},{"location":"gotchas/functiontype/","title":"Varying output type","text":"<p>The input type and output type of a function are fixed. So you can't write something like:</p> <pre><code>f 4 = True\nf 5 = 6\n</code></pre> <p>This is because the output type of <code>f</code> can be either always a <code>Bool</code>, as the first line implies, or always a number, as the second line implies.</p> <p>See this FAQ for the correct approach.</p>"},{"location":"gotchas/lists/","title":"Lists","text":"<p>\"Why does <code>[True, 4, \"cat\"]</code> give a type error?\"</p> <p>All elements of a list in Haskell must have the same type. This doesn't apply to tuples, like <code>(True, 4, \"cat\")</code>, which will work.</p>"},{"location":"gotchas/mutation/","title":"Updating a variable","text":"<p>\"I wrote a simple piece of code to update the value of <code>x</code>, but it hangs.\"</p> In a replIn a file   <pre><code>x = 0\nx = x + 1\nx\n</code></pre>   <pre><code>x = 0\nx = x + 1\nmain = print x\n</code></pre>    <p>In Haskell, values are always immutable. Writing <code>a = b</code> does not mean \"set the value of <code>a</code> to the current value of <code>b</code>\". It means \"bind the name <code>a</code> to the expression <code>b</code>. So you have asked Haskell to make <code>x</code> refer to the value <code>x + 1</code>. </p> <p>Haskell tries to fulfill your request. When you ask for <code>x</code> on the third line, it looks up its value, which is <code>x + 1</code>. It then looks up the value of <code>x</code> in <code>x + 1</code>, which again, is <code>x + 1</code>, to obtain <code>(x + 1) + 1</code>. This continues indefinitely, which is why the program hangs. </p>"},{"location":"gotchas/punning/","title":"Punning","text":"<p>It is common to see type definitions like the following:</p> <pre><code>data ChessPiece = ChessPiece Int Int\n</code></pre> <p>The first occurrence of <code>ChessPiece</code> is a type, but the second is a value, namely a function of type <code>Int -&gt; Int -&gt; ChessPiece</code>. </p> <p>The name of the type and value don't have to be the same, but it's common to make this choice to avoid having to invent a new name like <code>MkChessPiece</code>. </p>"},{"location":"gotchas/punning/#punning-and-recursive-types","title":"Punning and recursive types","text":"<p>There is even more potential for confusion when a type is recursive, so that the type can itself appear on the right hand side of its definition:</p> <pre><code>data BinTree = Leaf Int | BinTree BinTree BinTree\n--  type ^             value ^  type ^   type ^\n</code></pre> <p>Here, the second occurrence of <code>BinTree</code> is a value, and the rest are types.</p>"},{"location":"gotchas/punning/#common-examples-of-punning","title":"Common examples of punning","text":"<ul> <li><code>(Bool, Int)</code> is a type, but <code>(True, 4)</code> is a value</li> <li><code>[Bool]</code> is the type of lists of booleans, but <code>[True]</code> is a value, a list with a single element.</li> <li><code>()</code> is a type, and contains a single value, also called <code>()</code>.</li> <li><code>ReaderT</code> is both to a type, and a value, the constructor for that type. Similarly for <code>ExceptT</code>, <code>StateT</code> and others</li> </ul>"},{"location":"gotchas/show/","title":"Show value","text":"repl example<pre><code>&gt; data Piece = Bishop | Rook\n\n&gt; Bishop\n\"No instance for (Show Piece) arising from a use of \u2018print\u2019\"\n</code></pre> <p>Haskell is complaining that it doesn't have know how to serialize the value <code>Bishop</code> into a <code>String</code> (because <code>Piece</code> isn't an instance of the Show typeclass).</p> <p>Fix as follows:</p> repl example<pre><code>&gt; data Piece = Bishop | Rook deriving Show\n&gt; Bishop\nBishop\n</code></pre> <p>This instructs the compiler to create the obvious <code>Show</code> instance for <code>Piece</code>. </p>  <p>Note</p> <p>Haskell cannot derive a <code>Show</code> instance for all types - data types containing functions in particular are a problem because there is no obvious way to <code>show</code> them.</p>"},{"location":"gotchas/strings/","title":"Strings","text":"<p>Haskell has a legacy type for text called <code>String</code>, which is defined as <code>[Char]</code>, i.e. a list of characters. This is almost never a good representation of text, and should be avoided. Instead, use <code>Text</code> from the module <code>Data.Text</code>, after adding the package <code>text</code> to your requirements. </p> <p>Normally, <code>Text</code> is used in conjunction with the extension</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\n</code></pre> <p>which allows you to write text in the obvious way:</p> <pre><code>exampleText :: Text\nexampleText = \"blahblah\"\n</code></pre> <p>You may also use <code>OverloadedStrings</code> for other text representations, such as <code>ByteString</code>.</p>"},{"location":"gotchas/tupleLength/","title":"Length of tuple","text":"<p>When I ask for the length of a tuple, I get:</p> <pre><code>&gt; length [1,2,3]\n3\n&gt; length (True, False)\n1\n&gt; length ([True, False], True)\n1\n</code></pre> <p><code>length</code> works by calling a \"folding\" function, which relies on the <code>Foldable</code> typeclass. The <code>Foldable</code> instance for tuples is defined in such a way that the result of <code>length</code> is always <code>1</code>.</p> <p>While this is confusing, it is a consistent behavior.</p>"},{"location":"gotchas/typevsvalue/","title":"Confusing type and value","text":"<p>Don't confuse values and types. </p> <p>For example, the type <code>Pair</code></p> <pre><code>data Pair a = P a a \n</code></pre> <p>takes one type parameter, <code>a</code>, but the value <code>P</code> takes two arguments of the type <code>a</code>.</p> <pre><code>example :: Pair Bool\nexample = P True False \n</code></pre> <p>The danger of confusion is exacerbated by punning.</p>"},{"location":"laziness/laziness/","title":"Laziness","text":"<p>Haskell only evaluates an expression if it is needed for the computation as a whole:</p> repl example<pre><code>&gt; let x = undefined in x -- (3)!\n\" *** Exception: undefined\"\n&gt; let x = undefined in 3 + 5 -- (1)!\n8\n&gt; let x = undefined in (True || x) -- (2)!\nTrue\n</code></pre> <ol> <li><code>x</code> is never used, so is never evaluated, and the error never gets triggered.</li> <li><code>x</code> is never used here either, because if the first argument of <code>||</code> is <code>True</code>, it returns <code>True</code> without evaluating the second.</li> <li>undefined is a value that will throw a runtime error when evaluated.</li> </ol>"},{"location":"laziness/laziness/#infinite-data","title":"Infinite data","text":"<p>A common use case of lazy evaluation is to define an infinite piece of data, and only take a finite part.</p> repl example<pre><code>-- first example\n[1..]\n&lt;program hangs...&gt;\n&gt; take 10 [1..] -- (1)!\n[1,2,3,4,5,6,7,8,9,10]\n&gt; take 10 (filter even [1..])\n[2,4,6,8,10,12,14,16,18,20]\n\n-- second example\n&gt; let ones = 1 : ones\n&gt; take 10 ones\n[1,1,1,1,1,1,1,1,1,1]\n</code></pre> <ol> <li><code>[1..]</code> is an infinite list of all the integers (<code>[1,2,3,4...]</code>), so </li> </ol>  <p>Note</p> <p>Infinite lists in Haskell are similar to generators in Python, which can be thought of as the special case of lazy evaluation for lists.</p> <p>However, laziness applies to data structures other than lists, and is a pervasive feature of the language.</p>  <p>As a consequence, it is common to build an infinite structure recursively, and only consume a part, such as a finite prefix of this infinite list of prime numbers:</p> <pre><code>primes = filterPrime [2..]\n  where filterPrime (p:xs) =\n          p : filterPrime [x | x &lt;- xs, x `mod` p /= 0]\n</code></pre>  <p>Gotcha</p> <p>The consequences of laziness for algorithmic complexity analysis of purity and laziness are wide-ranging. For a good overview, see this article</p>"},{"location":"laziness/laziness/#mutual-recursion","title":"Mutual recursion","text":"<pre><code>func1 = 1 : func2\nfunc2 = 2 : func1\n</code></pre> <p>Then, <code>take 10 func1</code> gives <code>[1,2,1,2,1,2,1,2,1,2]</code>.</p>"},{"location":"laziness/laziness/#a-deeper-dive","title":"A deeper dive","text":"<p>See here for more resources on lazy algorithms and the performance implications of laziness.</p>"},{"location":"packages/aeson/","title":"JSON","text":"<p><code>Data.Aeson</code>, from the <code>aeson</code> package, is a library for encoding/decoding Haskell values to/from JSON.</p> <p>One of the main appeals of the library is that a JSON string, which is untyped, can be automatically parsed into a typed Haskell value.</p>"},{"location":"packages/aeson/#encoding-to-json","title":"Encoding to JSON","text":"repl example<pre><code>&gt; encode [4, 3]\n\"[4,3]\"\n&gt; encode [(4, 3)]\n\"[[4,3]]\"\n&gt; encode ['a', 'b']\n\"\\\"ab\\\"\"\n&gt; encode 4\n\"4\"\n\n\n&gt; encode (M.fromList [(\"John\", 12), (\"Jane\", 13)]) -- (1)!\n\"{\\\"Jane\\\":13,\\\"John\\\":12}\"\n\n-- an example with a custom datatype\n&gt; :set -XDeriveGeneric -XDeriveAnyClass -- (2)!\n&gt; data Piece = Bishop | Knight deriving (Generic, ToJSON)\n&gt; encode [Bishop, Knight]\n\"[\\\"Bishop\\\",\\\"Knight\\\"]\"\n</code></pre> <ol> <li>A dictionary.</li> <li>These are needed to derive <code>Generic</code> and <code>ToJSON</code> respectively.</li> </ol>"},{"location":"packages/aeson/#decoding-from-json","title":"Decoding from JSON","text":"repl example<pre><code>:set -XOverloadedStrings -- (1)!\nimport Data.Aeson\n\n&gt; eitherDecode \"[1,2,3]\" :: Either String [Int] -- (2)!\nRight [1,2,3]\n\n&gt; eitherDecode \"[1,2,\" :: Either String [Int]\nLeft \"Error in $: not enough input. Expecting json list value\" -- (3)!\n\n&gt; eitherDecode \"[1,2,3]\" :: Either String (Int, Int, Int)\nRight (1,2,3) -- (4)!\n\n&gt; eitherDecode \"[1,2,3]\" :: Either String (Int, Int, Double)\nRight (1,2,3.0) -- (5)!\n\n&gt; str = \"{ \\\"name\\\": \\\"Joe\\\", \\\"age\\\": \\\"12\\\" }\"\n&gt; eitherDecode str :: Either String (Map String String)\nRight (fromList [(\"age\",\"12\"),(\"name\",\"Joe\")])\n\n&gt; eitherDecode str :: Either String Value -- (6)!\nRight (Object (fromList [(\"age\",String \"12\"),(\"name\",String \"Joe\")]))\n</code></pre> <ol> <li> <p><code>aeson</code> uses the <code>ByteString</code> representation of text. See this gotcha</p> </li> <li> <p><code>eitherDecode</code> attempts to decode a JSON bytestring into a Haskell datatype.</p> </li> <li> <p>If it fails, it returns an error message.</p> </li> <li> <p>The result of the decoding depends on the type you specify. Both [Int] and (Int, Int, Int) work for decoding \"[1,2,3]\".</p> </li> <li> <p>As does <code>(Int, Int, Double)</code>.</p> </li> <li> <p><code>Value</code> is a type provided by <code>aeson</code> which corresponds to any JSON, but as a Haskell value.</p> </li> </ol> <p>The user can determine the Haskell type that the JSON should be decoded into. Types which are possible must implement the <code>FromJSON</code> typeclass, which is automatically implemented for many types, and can be derived automatically for custom types: </p> repl example<pre><code>&gt; :set -XDeriveGeneric -XDeriveAnyClass -XOverloadedStrings -- (1)!\n&gt; import GHC.Generics -- (2)!\n\n&gt; str = \"{ \\\"name\\\": \\\"Joe\\\", \\\"age\\\": 12 }\" -- (3)! \n\n&gt; data Person = Person { name :: Text, age  :: Int} \n    deriving (Generic, Show, FromJSON)\n\n\n&gt; eitherDecode str :: Either String Person\nRight (Person {name = \"Joe\", age = 12})\n</code></pre> <ol> <li>These extensions are needed.</li> <li>A library used for automatic derivations, among other things.</li> <li>The JSON bytestring.</li> </ol>"},{"location":"packages/aeson/#with-lenses","title":"With lenses","text":"<p>Lenses are an extremely useful tool for working with JSON in Haskell. See here</p>"},{"location":"packages/containers/","title":"Dictionaries and sets","text":"<p>A number of useful data structures are defined in the <code>containers</code> package.</p>"},{"location":"packages/containers/#maps","title":"Maps","text":"<p>Like a Python dictionary, this has unique (and orderable) keys, and arbitrary values. These must be of a single type.</p> repl example<pre><code>import qualified Data.Map as M\n\n&gt; hasRedHat = M.fromList [(\"John\", True), (\"Sally\", False), (\"Jane\", True)]\n&gt; hasRedHat\nfromList [(\"Jane\",True),(\"John\",True),(\"Sally\",False)]\n&gt; :t hasRedHat\nhasRedHat :: M.Map String Bool\n&gt; :t M.fromList\nM.fromList :: Ord k =&gt; [(k, a)] -&gt; M.Map k a\n\n-- look up\n&gt; M.lookup \"John\" hasRedHat \nJust True\n&gt; M.lookup \"Jim\" hasRedHat\nNothing\n</code></pre>"},{"location":"packages/containers/#sets","title":"Sets","text":"repl example<pre><code>&gt; import qualified Data.Set as S\n&gt; S.fromList [1,3,2,1,5,4,3]\nfromList [1,2,3,4,5]\n</code></pre>"},{"location":"packages/lens/","title":"Lenses","text":""},{"location":"packages/lens/#accessing-part-of-a-structure","title":"Accessing part of a structure","text":"<p>Lenses are the way to access and update parts of data structures in a pure functional way. Here are some examples using the <code>lens</code> package:</p> InfixPrefix   repl example<pre><code>&gt; import Control.Lens\n\n&gt; tuple = (True, ('a', 'b'))\n\n-- simple example: accessing the values inside a tuple\n&gt; tuple ^. _1 -- (1)!\nTrue\n&gt; tuple ^. _2\n('a','b')\n&gt; tuple ^. (_2 . _1) -- (2)!\n'a'\n\n-- updating parts of a data structure\n&gt; tuple &amp; _1 .~ 3 -- (3) (4)\n(3,('a','b'))\n&gt; tuple &amp; (_2 . _1) .~ 3\n(True,(3,'b'))\n&gt; tuple &amp; (_2 . _1) %~ toUpper\n(True,('A','b'))\n</code></pre> <ol> <li><code>_1</code> is a lens. It \"points\" towards a part of a data structure, in this case, the first element of a tuple. <code>^.</code> means: get the thing pointed to by the lens.</li> <li><code>(_2 . _1)</code> is a lens too! It points towards the 1st element of the 2nd element of a tuple.</li> <li>Note: <code>tuple &amp; _1 .~ 3</code> is a new tuple - it hasn't mutated the old one.</li> <li><code>&amp;</code> is just like <code>$</code> but in reverse: <code>x &amp; f = f x</code>.</li> </ol>   repl example<pre><code>&gt; tuple = (True, ('a', 'b'))\n&gt; view _1 tuple\nTrue\n&gt; view _2 tuple\n('a','b')\n&gt; view (_2 . _1) tuple\n'a'\n\n-- updating parts of a data structure\n&gt; set _1  3 tuple\n(3,('a','b'))\n&gt; set (_2 . _1) 3 tuple\n(True,(3,'b'))\n\n&gt; over (_2 . _1) toUpper tuple\n(True,('A','b'))\n</code></pre>"},{"location":"packages/lens/#updating-part-of-a-structure","title":"Updating part of a structure","text":"<p>You can also use the <code>lens</code> library to access or update multiple (or optional) parts of a data structure:</p> repl example<pre><code>import Control.Lens\n\n-- access multiple fields\n&gt; tuple = ((4, True), (3, False))\n&gt; tuple ^.. both -- (1)!\n[(4,True),(3,False)]\n&gt; tuple ^.. both . _2 -- (2)!\n[True,False]\n\n-- update multiple values\n&gt; tuple &amp; both . _2 %~ not\n((4,False),(3,True))\n\n-- example of an optional lookup\n&gt; ls = [(True, 'a'), (False, 'b'), (True, 'c')]\n\n&gt; ls ^.. ix 2 -- (3) (4)\n[(True,'c')]\n\n&gt; ls ^.. ix 4\n[]\n\n-- an example with a dictionary, or Map\n&gt; import qualified Data.Map as M\n&gt; dictionary = M.fromList [(\"John\", (True, 3)), (\"Sally\", (False, 1))]\n&gt; dictionary ^.. ix \"John\"\n[(True,3)]\n&gt; dictionary ^.. ix \"Jim\"\n[]\n&gt; dictionary ^.. (ix \"John\" . _1)\n[True]\n\n&gt; dictionary &amp; (ix \"John\" . _2) %~ (+1)\nfromList [(\"John\",(True,4)),(\"Sally\",(False,1))]\n</code></pre> <ol> <li><code>both</code> is a lens, or more precisely, a <code>Traversal</code>.</li> <li>Like other lenses and traversals, <code>both</code> can be composed, here with <code>_2</code>.</li> <li><code>ix n</code> looks up the element at the nth index of a structure.</li> <li>Since <code>ix n</code> may fail if <code>n</code> is out of bounds, it must be used with <code>^..</code></li> </ol>  <p>Note</p> <p>The <code>lens</code> package has two properties which make it unfriendly:</p> <ol> <li>A large set of packages it depends on.</li> <li>Sophisticated use of very abstract typeclasses, which results in hard-to-interpret error messages:</li> </ol> repl example<pre><code>import Control.Lens\n&gt; tuple = (True, ('a', 'b'))\n\n-- scary error message\n&gt; tuple ^. (_1 . _1)\n\"No instance for (Field1 Bool Bool () ())\"\n\n-- another scary error message\n&gt; tuple2 = (True, False)\n&gt; tuple2 ^. both\n\"No instance for (Monoid Bool) arising from a use of \u2018both\u2019\"\n</code></pre> <p>In either case, the error messages refer to typeclass constraints that your program requires, but without understanding the internals of the <code>lens</code> library, it is hard to make sense of these.</p> <p>The <code>optics</code> package aims to address these problems, with a different set of tradeoffs.</p>   <p>Gotcha</p> <p>Haskell is immutable, so when we talk about changing a data structure, we mean producing a new data structure that has that change. For example, to change the third element of <code>[1,2,3]</code> to <code>4</code> is to produce a new list <code>[1,2,4]</code>.</p>"},{"location":"packages/lens/#custom-data","title":"Custom data","text":"<p>You can write lenses for custom types, or generate them automatically with Template Haskell (a macro extension to Haskell):</p> <pre><code>{-# LANGUAGE TemplateHaskell #-} \nimport Control.Lens\n\ndata Point a\n  = Point { _x :: a, _y :: a }\nmakeLenses ''Point -- (1)!\n\nexample = Point {_x = 2, _y = 3}\n\nxVal = example ^. x\nyVal = example ^. y\n\nmain = print xVal\n</code></pre> <ol> <li>This is the syntax for a Template Haskell macro, here <code>makeLenses</code>, which <code>Control.Lens</code> exports.</li> </ol>"},{"location":"packages/lens/#useful-examples","title":"Useful examples","text":"<p>The <code>lens</code> library has an enormous range of useful tools, some of which are not easily discoverable. Here are some examples:</p>"},{"location":"packages/lens/#set","title":"Set","text":"repl example<pre><code>&gt; import qualified Data.Set as S\n&gt; numberSet = S.fromList [1,2,3,5]\n&gt; numberSet\nfromList [1,2,3,5]\n&gt; numberSet ^. contains 3\nTrue\n&gt; numberSet ^. contains 4\nFalse\n&gt; numberSet &amp; contains .~ 4\n\n-- even update a set this way!\n&gt; numberSet &amp; contains 4 .~ True\nfromList [1,2,3,4,5]\n\n&gt; numberSet &amp; contains 3 %~ not\nfromList [1,2,5]\n</code></pre>"},{"location":"packages/lens/#coercions","title":"Coercions","text":"repl example<pre><code>&gt; newtype Flag = Val Bool\n&gt; (Flag True &amp; coerced %~ not) :: Bool -- (1)!\nFalse\n</code></pre> <ol> <li><code>coerced</code> is a lens, which points towards the <code>Bool</code> inside a <code>B</code>.</li> </ol>"},{"location":"packages/lens/#json","title":"JSON","text":"<p>Lenses are particularly useful for working with JSON data, and can automate almost any querying or updating task, even very complex ones.</p> <p>Let's use this JSON as an example, saved in <code>\"data/file.json\"</code>:</p> <pre><code>{\n  \"firstName\": \"John\",\n  \"lastName\": \"Smith\",\n  \"isAlive\": true,\n  \"age\": 27,\n  \"address\": {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n    \"state\": \"NY\",\n    \"postalCode\": \"10021-3100\"\n  },\n  \"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [\n      \"Catherine\",\n      \"Thomas\",\n      \"Trevor\"\n  ],\n  \"spouse\": null\n}\n</code></pre> repl example<pre><code>-- read into a string\n&gt; json &lt;- readFile \"data/file.json\"\n&gt; json\n\"{\\n    \\\"firstName\\\": \\\"John\\\",\\n    \\\"lastName\\\": \\\"Smith\\\",\\n    \\\"isAlive\\\": true,\\n    \\\"age\\\": 27,\\n    \\\"address\\\": {\\n      \\\"streetAddress\\\": \\\"21 2nd Street\\\",\\n      \\\"city\\\": \\\"New York\\\",\\n      \\\"state\\\": \\\"NY\\\",\\n      \\\"postalCode\\\": \\\"10021-3100\\\"\\n    },\\n    \\\"phoneNumbers\\\": [\\n      {\\n        \\\"type\\\": \\\"home\\\",\\n        \\\"number\\\": \\\"212 555-1234\\\"\\n      },\\n      {\\n        \\\"type\\\": \\\"office\\\",\\n        \\\"number\\\": \\\"646 555-4567\\\"\\n      }\\n    ],\\n    \\\"children\\\": [\\n        \\\"Catherine\\\",\\n        \\\"Thomas\\\",\\n        \\\"Trevor\\\"\\n    ],\\n    \\\"spouse\\\": null\\n  }\"\n\n-- imports\n&gt; import Data.Aeson\n&gt; import Data.Aeson.Lens\n&gt; import Text.Pretty.Simple\n&gt; import Control.Lens\n\n-- view the underlying JSON data structure as a Haskell value \"inside\" the string:\n&gt; pPrint $ json ^.. _Value -- (3)!\n[ Object\n    ( fromList\n        [\n            ( \"address\"\n            , Object\n                ( fromList\n                    [\n                        ( \"city\"\n                        , String \"New York\"\n                        )\n                    ,\n                        ( \"postalCode\"\n                        , String \"10021-3100\"\n                        )\n                    ,\n                        ( \"state\"\n                        , String \"NY\"\n                        )\n                    ,\n                        ( \"streetAddress\"\n                        , String \"21 2nd Street\"\n                        )\n                    ]\n                )\n            )\n...\n\n&gt; query (_Value . key \"address\" . key \"city\") -- (2)!\n[ String \"New York\" ]\n\n&gt; query (_Value . key \"children\" . nth 2)\n[ String \"Trevor\" ]\n\n&gt; query (_Value . key \"children\" . nth 1)\n[ String \"Thomas\" ]\n\n&gt; query (_Value . key \"spouse\" . nth 1) -- (4)!\n[]\n\n&gt; query (_Value . key \"children\" . values)\n[ String \"Catherine\"\n, String \"Thomas\"\n, String \"Trevor\"\n]\n</code></pre> <ol> <li>This is a Haskell data structure (of type <code>Value</code> from <code>Data.Aeson</code>) which represents the JSON. </li> <li>As usual, we can compose lenses</li> <li><code>pPrint</code> is a pretty printing function. The lens (or more precisely, the traversal) is <code>_Value</code>.</li> <li>Since there is no list inside the entry for \"spouse\", this returns no results.</li> </ol> <p>The most powerful use cases involve recursively searching the JSON, using a lens which (lazily) points to every JSON subpart in the JSON as a whole:</p> repl example<pre><code>-- for all Strings in the JSON, show them\n&gt; pPrint $ json ^.. _Value . cosmos . _String\n[ \"New York\"\n, \"10021-3100\"\n, \"NY\"\n, \"21 2nd Street\"\n, \"Catherine\"\n, \"Thomas\"\n, \"Trevor\"\n, \"John\"\n, \"Smith\"\n, \"212 555-1234\"\n, \"home\"\n, \"646 555-4567\"\n, \"office\"\n]\n\n-- for all Strings in the JSON underneath the key \"address\", show them:\n&gt; pPrint $ json ^.. _Value . key \"address\" . cosmos . _String\n[ \"New York\"\n, \"10021-3100\"\n, \"NY\"\n, \"21 2nd Street\"\n]\n\n-- for all arrays in the JSON that contain at least 3 elements, show the third:\n&gt; pPrint $ json ^.. _Value . cosmos . _Array . ix 2\n[ String \"Trevor\" ]\n</code></pre> <p>One can similarly update the raw JSON string in a structured way with lenses:</p> repl example<pre><code>-- modify the string corresponding to the address's city to be uppercase\n&gt; json &amp; _JSON' @String @Value . key \"address\" . key \"city\" . _String %~ T.map toUpper\n\"{\\\"address\\\":{\\\"city\\\":\\\"NEW YORK\\\",\\\"postalCode\\\":\\\"10021-3100\\\",\\\"state\\\":\\\"NY\\\",\\\"streetAddress\\\":\\\"21 2nd Street\\\"},\\\"age\\\":27,\\\"children\\\":[\\\"Catherine\\\",\\\"Thomas\\\",\\\"Trevor\\\"],\\\"firstName\\\":\\\"John\\\",\\\"isAlive\\\":true,\\\"lastName\\\":\\\"Smith\\\",\\\"phoneNumbers\\\":[{\\\"number\\\":\\\"212 555-1234\\\",\\\"type\\\":\\\"home\\\"},{\\\"number\\\":\\\"646 555-4567\\\",\\\"type\\\":\\\"office\\\"}],\\\"spouse\\\":null}\"\n</code></pre>"},{"location":"packages/megaparsec/","title":"Parsing","text":"<p>Parser combinators are a technique for parsing. </p> <p><code>megaparsec</code> (and a more restrictive but faster library, <code>attoparsec</code>) are industrial strength parser combinator libraries in Haskell.</p>"},{"location":"packages/megaparsec/#external-resources","title":"External resources","text":"<p>This tutorial explains how to use <code>megaparsec</code> in detail.</p> <p>This tutorial explains the design and implementation of parser combinators.</p>"},{"location":"packages/megaparsec/#what-are-parsers","title":"What are parsers?","text":"A very simple version of a parser<pre><code>import Data.Char (digitToInt, isDigit)\n\ntype Parser a = [Char] -&gt; Maybe (a, [Char]) -- (1)!\n\ndigit :: Parser Int -- (2)!\ndigit (x:xs) \n  | isDigit x = Just (digitToInt x, xs) \n  | otherwise = Nothing\ndigit [] = Nothing\n</code></pre> <ol> <li> <p>A <code>Parser</code> (parameterized by some type <code>a</code>), takes a sequence of characters to be parsed, and either fails or returns a parse result from some initial segment of the sequence and the remaining sequence with that segment removed.</p> </li> <li> <p><code>digit</code> is a <code>Parser</code> parameterized by <code>Int</code> (which is the type of its result). It will try to strip a numeral (<code>1</code>, <code>2</code>, etc..) from the input sequence. If the sequence does not begin with a digit, it will fail (i.e., return <code>Nothing</code>). If it succeeds, it will return an <code>Int</code>, not a <code>Char</code>.</p> </li> </ol> <p>Libraries like <code>parsec</code>, <code>megaparsec</code> and <code>attoparsec</code> provide more sophisticated versions of this idea:</p> repl example<pre><code>&gt; import Text.Megaparsec\n&gt; import Text.Megaparsec.Char\n&gt; :set -XOverloadedStrings\n\n&gt; type Parser = Parsec Void T.Text\n\n-- (1)!\n&gt; parseWith parser = putStrLn . (either errorBundlePretty T.unpack ) . parse parser \"\"\n\n-- (3)!\n&gt; aParser = \"a\" :: Parser T.Text\n\n&gt; parseWith aParser \"ab\"\na\n&gt; parseWith aParser \"ba\" -- (2)!\n1:1:\n  |\n1 | ba\n  | ^\nunexpected 'b'\nexpecting 'a'\n\n\nabParser = \"ab\" :: Parser T.Text\n&gt; parseWith abParser \"ab\" \nab\n\n&gt; parseWith abParser \"ba\"\n1:1:\n  |\n1 | ba\n  | ^^\nunexpected \"ba\"\nexpecting \"ab\"\n</code></pre> <ol> <li>A helper function for parsing.</li> <li><code>megaparsec</code> generates pretty error messages when it fails.</li> <li><code>Parser T.Text</code> is the type of a parser that returns a result of type <code>T.Text</code></li> </ol>"},{"location":"packages/megaparsec/#what-are-combinators","title":"What are combinators","text":"<p>Parser combinator libraries provide not just simple parsers like the above, but the ability to combine parsers to build more complex ones.</p> <p>Here are examples from <code>megaparsec</code>:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Data.Text ( Text, unpack ) \nimport Data.Void (Void)\nimport Text.Megaparsec.Char (space)\n\n\ntype Parser = Parsec Void Text\n\n-- helper function to run parser\nparseAndPrint :: Show b =&gt; Parsec Void Text b -&gt; Text -&gt; IO ()\nparseAndPrint parser line =\n  either\n    (putStrLn . errorBundlePretty)\n    print\n    (runParser parser \"\" line)\n\n-- parse 'a' then 'b'\nabParser :: Parser Text\nabParser = \"ab\" -- (2)!\n\n-- parse 'b' then 'a'\nbaParser :: Parser Text\nbaParser = \"ba\"\n\n-- parse 'ab' then 'ba'\nabbaParser :: Parser Text -- (1)!\nabbaParser = do \n  ab &lt;- abParser -- (3)!\n  ba &lt;- baParser -- (4)!\n  return (ab &lt;&gt; ba) -- (5)!\n\n-- parse either 'ba' or 'ab'\nbaOrabParser :: Parser Text\nbaOrabParser = baParser &lt;|&gt; abParser -- (6)!\n\nmain :: IO ()\nmain = parseAndPrint baOrabParser \"ab\"\n</code></pre> <p>This runs as follows:</p> repl example<pre><code>&gt; parseAndPrint baParser \"ba\"\n\"ba\"\n&gt; parseAndPrint baParser \"ab\"\n1:1:\n  |\n1 | ab\n  | ^^\nunexpected \"ab\"\nexpecting \"ba\"\n\n&gt; parseAndPrint baOrabParser \"ab\"\n\"ab\"\n&gt; parseAndPrint abbaParser \"abba\"\n\"abba\"\n&gt; parseAndPrint abbaParser \"baab\"\n1:1:\n  |\n1 | baab\n  | ^^\nunexpected \"ba\"\nexpecting \"ab\"\n</code></pre> <ol> <li><code>Parser</code> is a monad, so we can use do-notation, which is very convenient for building complex parsers out of simpler ones.</li> <li><code>megaparsec</code> takes advantage of OverloadedStrings, so that <code>\"ab\"</code> is actually a parser.</li> <li>This means: run <code>abParser</code> and name the result <code>ab</code>.</li> <li>This means: run <code>baParser</code> (on what remains after running <code>abParser</code> previously) and name the result <code>ba</code>.</li> <li>This means: the result of the parser is the value <code>ab &lt;&gt; ba</code>.</li> <li>This means: try first <code>baParser</code> and if it fails, try <code>abParser</code>.</li> </ol>"},{"location":"packages/megaparsec/#with-custom-types","title":"With custom types","text":"<p>One of the main appeals of Haskell's parser combinators is that the output of your parser can be a custom type:</p> <pre><code>data PieceType = Bishop | Rook deriving Show\ndata Color = White | Black deriving Show\ndata Piece = Piece PieceType Color deriving Show\n\npieceTypeParser :: Parser PieceType -- (3)!\npieceTypeParser = do\n  str &lt;- \"bishop\" &lt;|&gt; \"rook\"\n  return $ case str of\n    \"bishop\" -&gt; Bishop\n    _ -&gt; Rook\n\ncolorParser :: Parser Color\ncolorParser = do\n  str &lt;- \"white\" &lt;|&gt; \"black\"\n  return $ case str of\n    \"white\" -&gt; White\n    _ -&gt; Black\n\npieceParser :: Parser Piece\npieceParser = do\n  color &lt;- colorParser\n  space -- (1)!\n  pieceType &lt;- pieceTypeParser\n  return (Piece pieceType color)\n\noptionalColorParser :: Parser Piece\noptionalColorParser = do\n  maybeColor &lt;- optional colorParser -- (2)!\n  pieceType &lt;- pieceTypeParser\n  return $ case maybeColor of\n    Just color -&gt; Piece pieceType color\n    Nothing -&gt; Piece pieceType White\n</code></pre> <ol> <li>0 or more whitespace.</li> <li><code>optional</code> takes <code>colorParser</code> and returns a new parser that either parses nothing or <code>colorParser</code>. The result, appropriately, is a <code>Maybe Color</code>.</li> <li>The result type is the custom type just defined above.</li> </ol> <p>Examples:</p> repl example<pre><code>&gt; parseAndPrint optionalColorParser \"white rook\"\nPiece Rook White\n&gt; parseAndPrint optionalColorParser \"rook\"\nPiece Rook White\n&gt; parseAndPrint pieceParser \"white rook\"\nPiece Rook White'\n&gt; parseAndPrint pieceParser \"rook\"\n1:1:\n  |\n1 | rook\n  | ^^^^\nunexpected \"rook\"\nexpecting \"black\" or \"white\"\n</code></pre>"},{"location":"packages/mtl/","title":"Side-Effects","text":"<p>Warning</p> <p>Understand monads, do-notation, and in particular the <code>State</code> and <code>Except</code> monads in advance will make the content of this page more transparent.</p>  <p>In imperative programming languages, it is straightforward to write code which performs \"side effects\", like:</p> <ul> <li>throwing an error</li> <li>reading from a file</li> <li>reading from an environment variable</li> <li>writing to a log</li> <li>mutating a local variable</li> <li>non-determinism: multiple computation paths are taken</li> </ul> <p>A standard way in Haskell to have these abilities in a pure functional setting is with the use of types like <code>Maybe</code>, <code>State</code> or <code>Reader</code>. Because these have <code>Monad</code> instances, one can write imperative style code like:</p> <pre><code>{-# LANGUAGE OverloadedStrings #-}\nimport Control.Monad.State\nimport Control.Monad.Reader\nimport Control.Monad.Except\nimport Data.Text (Text)\n\nexample :: State Bool ()\nexample = do\n    flag &lt;- get\n    put (not flag) \n</code></pre>"},{"location":"packages/mtl/#transformers","title":"Transformers","text":"<p>Simple monads tend to only express one of the above effects, so a system for combining them is needed. One approach is to build more complex types modularly, like <code>StateT Bool (Except Text)</code> and define the corresponding <code>Monad</code> instances in a library.</p> <p>This is what the transformers library does, thus called because <code>StateT</code>, <code>ExceptT</code>, <code>ReaderT</code> and so on are known as monad transformers. Here are some of their definitions:</p> <ul> <li><code>data StateT s m a = StateT {runStateT :: s -&gt; m (a, s)}</code></li> <li><code>newtype ExceptT e m a = ExceptT {runExceptT :: m (Either e a)}</code></li> </ul>  Note <p><code>StateT</code> (like <code>ExceptT</code>) is parametrized by three types:</p> <ul> <li>the type of the state <code>s</code></li> <li>the type of the underlying monad <code>m</code></li> <li>the return type of the whole monad, <code>a</code>.</li> </ul> <p>It has kind: <code>* -&gt; (* -&gt; *) -&gt; * -&gt; *</code>.</p>  <p>For example, <code>StateT Bool (Except Text) Int</code> is equivalent to:</p> <pre><code>(Bool -&gt; Either Text (Int, Bool))\n</code></pre> <p>so represents an <code>Int</code> value or failure that results from a boolean state (which could change).</p>  Note <p>Meanwhile, <code>ExceptT Text (State Bool) Int</code> is equivalent to:</p> <pre><code>(Bool -&gt; (Either Text Int, Bool))\n</code></pre> <p>which is similar, except that the new state is obtained whether or not there is a failure.</p>  <p>However, these types (sometimes referred to as monad transformer stacks) tend to be cumbersome to work with, and involve the ungainly use of a <code>lift</code> function to coerce types into the right shapes.</p>"},{"location":"packages/mtl/#abstracting-the-typeclasses","title":"Abstracting the typeclasses","text":"<p><code>mtl</code>1 is a widely used library designed to make the experience smoother, which supplies typeclasses that work in conjunction with <code>transformers</code>. Here is an example with error throwing and local variable updating:</p> with <code>if</code>with <code>when</code>   <pre><code>example2 :: (MonadError Text m, MonadState Bool m) =&gt; m Bool\nexample2 = do\n    flag &lt;- get\n    if flag\n        then \n            put (not flag) \n            &gt;&gt; throwError \"flag should not have been on!\"\n        else pure ()\n    return flag\n</code></pre>   <pre><code>example3 :: (MonadError Text m, MonadState Bool m) =&gt; m Bool\nexample3 = do\n    flag &lt;- get\n    when flag $ \n        put (not flag) \n        &gt;&gt; throwError \"flag should not have been on!\"\n    return flag\n</code></pre>    <p>The type of <code>example</code> is abstracted over the concrete monad transformer stack, which could either be <code>ExceptT Text (State Bool)</code> or <code>StateT Bool (Except Text)</code>. </p> <p>Depending on how <code>example</code> is called, either of these can end up being the concrete type that is inferred and used:</p> Error over stateState over error   <pre><code>errorOverState :: Bool -&gt; IO ()\nerrorOverState flagVal = \n    let (result, state) = flip runState flagVal $ runExceptT example2\n    in do\n        putStrLn (\"Result: \" &lt;&gt; show result)\n        putStrLn (\"State: \" &lt;&gt; show state)\n\nmain :: IO ()\nmain = do\n    errorOverState True\n    errorOverState False\n</code></pre> <p>results in:</p> repl example<pre><code>&gt; errorOverState False\nResult: Right False\nState: False\n&gt; errorOverState True\nResult: Left \"flag should not have been on!\"\nState: False\n</code></pre>   <pre><code>stateOverError :: Bool -&gt; IO ()\nstateOverError flagVal = case runExcept $ flip runStateT flagVal example of\n    Left err -&gt; putStrLn (\"Error: \" &lt;&gt; show err)\n    Right (result, state) -&gt; do\n        putStrLn (\"Result: \" &lt;&gt; show result)\n        putStrLn (\"State: \" &lt;&gt; show state) \n</code></pre> <p>results in</p> repl example<pre><code>&gt; stateOverError False\nResult: False\nState: False\n&gt; stateOverError True\nError: \"flag should not have been on!\"\nState: False\n</code></pre>     Note <p><code>Except</code> is a type synonym for <code>ExceptT Identity</code>, where <code>Identity</code> is the monad which does nothing whatsoever.</p>   <p>Gotcha</p> <p>Alternatives to <code>mtl</code> have become popular in recent years, such as Polysemy and cleff. These are often experimental, or require slightly more advanced use of types (e.g. type level lists) and so are recommended for experienced Haskellers only.</p>    <ol> <li> <p>Short for: monad transformer library\u00a0\u21a9</p> </li> </ol>"},{"location":"packages/overview/","title":"How to use libraries","text":"<p>Library API documentation is typically autogenerated from code comments, to create online interactive docs. </p>"},{"location":"packages/overview/#example","title":"Example","text":"<p>As an example, <code>gloss</code> is a package for 2D animation and games. Here are its API docs, where you can find the following package list:</p>  <p>For well-maintained packages, you should expect to find some explanation of the package's goals and uses either on this front page or in the top-level module (here <code>Graphics.Gloss</code>).</p>  <p>Warning</p> <p>Many published packages are experimental code, not intended for serious use. To get a sense of which packages to use, see this guide.</p>"},{"location":"packages/overview/#hackage-and-stackage","title":"Hackage and Stackage","text":"<p>There exist two major package repositories for Haskell, Hackage and Stackage, with the main difference that Stackage provides a stabler subset of Hackage, which is more extensive. </p>"},{"location":"packages/overview/#how-to-read-haskell-documentation","title":"How to read Haskell documentation","text":"<p>Haskell's expressive types are usually very helpful in understanding how to use a library. For example, the following function appears near the top of the docs in the top level module:</p>  <p>From the type signature, we see that we get a runnable process (i.e. a value of type <code>IO ()</code>) if we supply a few arguments, like <code>Color</code> and a function <code>Float -&gt; Picture</code>.</p> <p>We can then understand what <code>Picture</code> is by following the link, to see its definition:</p>"},{"location":"packages/overview/#default-libraries","title":"Default libraries","text":"<p>Haskell's Prelude library is automatically imported into every module, and includes many familiar functions and types, like <code>take</code> and <code>Maybe</code>. </p>  <p>Note</p> <p><code>Prelude</code> is sometimes replaced by a different base library in large projects, since it includes legacy features and outdated design decisions. For example, the function <code>head</code> is unsafe in the sense that it throws a hard error when you take the head of an empty list: <code>head []</code>.</p> <p>A good modern alternative can be found here.</p>"},{"location":"packages/quickcheck/","title":"Property-based testing","text":"<p>In addition to unit testing, Haskell has powerful libraries for property based testing. This is testing where you specify a property you think your program should have, and the testing library tries to find a counterexample. </p>  <p>Tip</p> <p>Much like unit tests, the success of property tests is not a guarantee of your code's correctness, but it can be a extremely effective way to find bugs quickly.</p>  repl example<pre><code>import Test.QuickCheck -- (1)!\n\n-- Assert that all lists have length 0\n&gt; quickCheck (\\x -&gt; length x == 0)\n*** Failed! Falsified (after 2 tests):    -- (2)!              \n[()] -- (3)!\n\n-- Assert that all lists have length 0 or greater\n&gt; quickCheck (\\x -&gt; length x &gt;= 0)\n+++ OK, passed 100 tests.  \n\n-- Assert that for any numbers a and b, a+b is the same as b+a\n&gt; quickCheck (\\a b -&gt; a + b == b + a)\n+++ OK, passed 100 tests\n\n&gt; import Data.Maybe\n-- Assert that if the left element of a tuple is not Nothing, neither is the right\n&gt; property = (\\(x,y) -&gt; isJust x ==&gt; isJust y) -- (4)!\n&gt; quickCheck property\n*** Failed! Falsified (after 1 test):                  \n(Just (),Nothing)\n\n-- sanity check custom sorting function\n&gt; import Data.List (sort) -- (5)!\n&gt; mkListProperty sortFn (ls :: [Int]) = sortFn ls == sort ls\n&gt; badSort = reverse -- (6)!\n&gt; quickCheck (mkListProperty badSort)\n*** Failed! Falsified (after 5 tests and 3 shrinks):    \n[0,1]\n</code></pre> <ol> <li>This requires the QuickCheck package.</li> <li><code>QuickCheck</code> generates lists randomly until it finds a counterexample to your claim, and then simplifies it to a minimal counterexample.</li> <li>In this case, the counterexample is the one element list containing the unit value <code>()</code>, namely <code>[()]</code></li> <li><code>==&gt;</code> is exported by <code>QuickCheck</code>; <code>a ==&gt; b</code> (read: <code>a</code> implies <code>b</code>) evaluates to <code>False</code> if and only if <code>a</code> is True but <code>b</code> is <code>False</code>. </li> <li><code>sort</code> is a trusted sorting function from <code>Data.List</code>.</li> <li><code>badSort</code> is a bad sorting algorithm: it just reverses its input.</li> </ol>  <p>Warning</p> <p>Try to avoid universal quantification when not necessary in properties. For example, <code>property sortFn ls = sortFn ls == sort ls</code> really ought to have a type signature, so that <code>QuickCheck</code> knows what the type of the elements of the list are, and can generate appropriate examples. Otherwise it will default to a type (usually <code>()</code>).</p>"},{"location":"packages/quickcheck/#custom-data-types","title":"Custom data types","text":"<p>Properties involving custom types require that you provide an instance of the <code>Arbitrary</code> typeclass for your type, like so:</p> <pre><code>import Test.QuickCheck (Arbitrary (arbitrary), elements, quickCheck)\nimport Data.List (sort)\n\n\ndata Piece = Bishop | Rook deriving (Eq, Show, Ord)\n\ninstance Arbitrary Piece where\n    arbitrary = elements [Rook, Bishop] -- (1)!\n\nexampleProperty :: [Piece] -&gt; Bool -- (2)!\nexampleProperty ls = sort ls == [Bishop, Rook]\n\nmain :: IO ()\nmain = quickCheck exampleProperty\n</code></pre> <ol> <li><code>arbitrary</code> is the function which generates a <code>Piece</code>. This implementation says: draw it as random from the list <code>[Rook, Bishop]</code>.</li> <li>Because <code>Piece</code> has an <code>Arbitrary</code> instance, Haskell can automatically obtain an <code>Arbitrary</code> instance for <code>[Piece]</code>, <code>Maybe Piece</code>, and so on.</li> </ol>"},{"location":"packages/recursion-schemes/","title":"Recursion schemes","text":"<pre><code>{-# LANGUAGE BlockArguments #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE LambdaCase #-}\nimport Data.Functor.Foldable\nimport Data.Fix (Fix(..))\nimport Data.Text (Text)\n\n\ndata TreeStructure a where\n  Leaf :: Text -&gt; TreeStructure a\n  Branches :: a -&gt; a -&gt; TreeStructure a \n  deriving Functor\n\ntype Tree = Fix TreeStructure\n\nprettyPrint :: Tree -&gt; Text \nprettyPrint = cata \\case\n    Leaf text -&gt; text\n    Branches a b -&gt; \"(\" &lt;&gt; a &lt;&gt; \" \" &lt;&gt; b &lt;&gt; \")\"\n\nmain = print $ prettyPrint $ Fix $ (Branches (Fix $ Leaf \"hello\") (Fix $ Leaf \"world\"))\n\n-- &gt;&gt;&gt; 4 + 4\n</code></pre>"},{"location":"packages/survey/","title":"Overview of the ecosystem","text":"<p>Disclaimer</p> <p>This section is adapted from Gabriella Gonzalez' State of the Ecosystem, which is licensed here.</p> <p>Some of the text has been cropped or modified.</p>  Contributors <ul> <li>Aaron Levin</li> <li>Alois Cochard</li> <li>Ben Kovach</li> <li>Benno F\u00fcnfst\u00fcck</li> <li>Carlo Hamalainen</li> <li>Chris Allen</li> <li>Curtis Gagliardi</li> <li>Deech</li> <li>David Howlett</li> <li>David Johnson</li> <li>Edward Cho</li> <li>Greg Weber</li> <li>Gregor Uhlenheuer</li> <li>Juan Pedro Villa Isaza</li> <li>Kazu Yamamoto</li> <li>Kevin Cantu</li> <li>Kirill Zaborsky</li> <li>Liam O'Connor-Davis</li> <li>Luke Randall</li> <li>Marcio Klepacz</li> <li>Mitchell Rosen</li> <li>Nicolas Kaiser</li> <li>Oliver Charles</li> <li>Pierre Radermecker</li> <li>Rodrigo B. de Oliveira</li> <li>Stephen Diehl</li> <li>Tim Docker</li> <li>Tran Ma</li> <li>Yuriy Syrovetskiy</li> <li>@bburdette</li> <li>@co-dan</li> <li>@ExternalReality</li> <li>@GetContented</li> <li>@psibi</li> <li>@newswim</li> </ul>    <p>Legend</p> <p>\ud83c\udfc6 = Best in class: the best experience in any language</p> <p>\ud83e\udd48 = Mature: suitable for most programmers</p> <p>\ud83c\udf31 = Immature: acceptable for early-adopters</p> <p>\u26d4 = Undeveloped</p>"},{"location":"packages/survey/#compilers","title":"\ud83c\udfc6 Compilers","text":"<p>Notable libraries:</p> <ul> <li><code>parsec</code> / <code>megaparsec</code> / <code>attoparsec</code> / <code>trifecta</code> / <code>alex</code>+<code>happy</code> - parsing libraries</li> <li><code>bound</code> / <code>unbound</code> - manipulating bound variables</li> <li><code>hoopl</code> - optimization</li> <li><code>uuagc</code> - attribute grammars</li> <li><code>unification-fd</code> - fast structural unification</li> <li><code>prettyprinter</code> - pretty-printing</li> <li><code>llvm-general</code> - LLVM 3.5 API</li> <li><code>llvm-hs</code> - LLVM 5 API (actively maintained fork of llvm-general)</li> <li><code>language-</code>{<code>ecmascript</code>|<code>python</code>|<code>c-quote</code>|<code>lua</code>|<code>java</code>|<code>objc</code>|<code>cil</code>} - parsers and    pretty-printers for other languages</li> </ul>  Commentary <p>Haskell originated in academia, and most languages of academic origin (such as the ML family of languages) excel at compiler-related tasks for obvious reasons.  As a result the language has a rich ecosystem of libraries dedicated to compiler-related tasks, such as parsing, pretty-printing, unification, bound variables, syntax tree manipulations, and optimization.</p> <p>Some compilers written in Haskell:</p> <ul> <li><code>Elm</code></li> <li><code>Purescript</code></li> <li><code>Idris</code></li> <li><code>Agda</code></li> <li><code>Pugs</code> (the first Perl 6 implementation)</li> <li><code>ghc</code> (self-hosting)</li> <li><code>frege</code> (very similar to Haskell, also self-hosting)</li> <li><code>hython</code> (a Python3 interpreter written in Haskell)</li> <li><code>Lasca</code> (a small Scala-like language with global type inference and optional dynamic mode on LLVM backend)</li> <li><code>verve</code> - Functional language with object-oriented support</li> <li><code>sixten</code> - Haskell/Idris-style language with a focus on precise and efficient memory layout</li> <li><code>carp</code> - An efficient, statically typed Lisp with ownership tracking.</li> <li><code>unison</code> - A purely functional distributed programming language with algebraic effects.</li> <li><code>oden</code> (no longer in active development)</li> </ul> <p>Educational resources:</p> <ul> <li>Write you a Haskell</li> <li>A Tutorial Implementation of a Dependently Typed Lambda Calculus</li> <li>Binders Unbound</li> </ul> <p>Success stories:</p> <ul> <li>Oden restrospective on rewrite from Racket to Haskell</li> </ul>"},{"location":"packages/survey/#single-machine-concurrency","title":"\ud83c\udfc6 Single-machine Concurrency","text":"<p>Notable libraries:</p> <ul> <li><code>stm</code> - Software transactional memory</li> <li><code>unagi-chan</code> - High performance channels</li> <li><code>async</code> - Futures library</li> <li><code>streamly</code> - A streaming library offering high performance concurrency</li> </ul>  Commentary <p>Haskell's concurrency runtime performs as well or better than other mainstream languages and is significantly easier to use due to the runtime support for software-transactional memory.</p> <p>The best explanation of Haskell's threading module is the documentation in <code>Control.Concurrent</code>:</p>  <p>Concurrency is \"lightweight\", which means that both thread creation and context switching overheads are extremely low. Scheduling of Haskell threads is done internally in the Haskell runtime system, and doesn't make use of any operating system-supplied thread packages.</p>  <p>In Haskell, all I/O is non-blocking by default, so for example a web server will just spawn one lightweight thread per connection and each thread can be written in an ordinary synchronous style instead of nested callbacks like in Node.js.</p> <p>The best way to explain the performance of Haskell's threaded runtime is to give hard numbers:</p> <ul> <li>The Haskell thread scheduler can easily handle millions of threads</li> <li>Each thread requires 1 kb of memory, so the hard limitation to thread count is memory (1 GB per million threads).</li> <li>Haskell channel overhead for the standard library (using <code>TQueue</code>) is on the order of one microsecond per message and degrades linearly with increasing contention</li> <li>Haskell channel overhead using the <code>unagi-chan</code> library is on the order of 100 nanoseconds (even under contention)</li> <li>Haskell's <code>MVar</code> (a low-level concurrency communication primitive) requires 10-20 ns to add or remove values (roughly on par with acquiring or releasing a lock in other languages)</li> </ul> <p>Haskell also provides software-transactional memory, which allows programmers build composable and atomic memory transactions.  You can compose transactions together in multiple ways to build larger transactions:</p> <ul> <li>You can sequence two transactions to build a larger atomic transaction</li> <li>You can combine two transactions using alternation, falling back on the second transaction if the first one fails</li> <li>Transactions can retry, rolling back their state and sleeping until one of their dependencies changes in order to avoid wasteful polling</li> </ul> <p>A few other languages provide software-transactional memory, but Haskell's implementation has two main advantages over other implementations:</p> <ul> <li>The type system enforces that transactions only permit reversible memory modifications.  This guarantees at compile time that all transactions can be safely rolled back.</li> <li>Haskell's STM runtime takes advantage of enforced purity to improve the efficiency of transactions, retries, and alternation.</li> </ul> <p>Haskell is also the only language that supports both software transactional memory and non-blocking I/O.</p> <p>Educational resources:</p> <ul> <li>Parallel and Concurrent Programming in Haskell</li> <li>Parallel and Concurrent Programming in Haskell - Software transactional memory</li> <li>Beautiful concurrency - a software-transactional memory tutorial</li> <li>Performance numbers for primitive operations - Latency timings for various low-level operations</li> </ul> <p>Success Stories:</p> <ul> <li>What is the Haskell response to Node.js?</li> <li>Haskell and non-blocking asynchronous IO</li> </ul>"},{"location":"packages/survey/#parsing-pretty-printing","title":"\ud83c\udfc6 Parsing / Pretty-printing","text":"<p>Parsing libraries:</p>  <ul> <li><code>megaparsec</code> - Modern, actively maintained fork of <code>parsec</code></li> <li><code>attoparsec</code> - Extremely fast backtracking parser</li> <li><code>Earley</code> - Earley parsing   embedded within the Haskell language.  Parses all context-free   grammars, even ambiguous ones, with no need to left factor.   Returns all valid parses.</li> <li><code>trifecta</code> - Best error messages (<code>clang</code>-style)</li> <li><code>parsers</code> - Interface compatible with <code>attoparsec</code>, <code>parsec</code> and <code>trifecta</code> which lets you easily switch between them.  People commonly use this library to begin with <code>trifecta</code> or <code>parsec</code> (for better error messages) then switch to <code>attoparsec</code> when done for performance</li> <li><code>alex</code> / <code>happy</code> - Like <code>lexx</code> / <code>yacc</code> but with Haskell integration</li> </ul>  Commentary <p>Haskell parsing is extremely powerful.  Recursive descent parser combinators are far-and-away the most popular parsing paradigm within the Haskell ecosystem, so much so that people use them even in place of regular expressions. </p> <p>If you're not sure what library to pick, we generally recommend the <code>megaparsec</code> library as a default well-rounded choice because it strikes a decent balance between ease-of-use, performance, good error messages, and small dependencies.</p> <p><code>attoparsec</code> deserves special mention as an extremely fast backtracking parsing library.  The speed and simplicity of this library will blow you away.  The main deficiency of <code>attoparsec</code> is the poor error messages.</p> <p>The pretty-printing front is also excellent.  Academic researchers just really love writing pretty-printing libraries in Haskell for some reason.</p> <p>Pretty-printing libraries:</p> <ul> <li><code>prettyprinter</code> - Pretty-printing library</li> <li><code>text-format</code> - High-performance string formatting</li> </ul> <p>Educational resources:</p> <ul> <li>Monadic Parsing in Haskell</li> </ul> <p>Success Stories:</p> <ul> <li>A major upgrade to attoparsec: more speed, more power</li> </ul>"},{"location":"packages/survey/#server-side-web-programming","title":"\ud83e\udd48 Server-side web programming","text":"<p>Notable libraries:</p> <ul> <li><code>aeson</code> - Parsing and generation of JSON</li> <li><code>warp</code> / <code>wai</code> - the low-level server and API that all server libraries share, with the exception of <code>snap</code></li> <li><code>scotty</code> - A beginner-friendly server framework analogous to Ruby's Sinatra</li> <li><code>spock</code> - Lighter than the \"enterprise\" frameworks, but more featureful than scotty (type-safe routing, sessions, conn pooling, csrf protection, authentication, etc)</li> <li><code>yesod</code> / <code>yesod-*</code> / <code>snap</code> / <code>snap-*</code> / <code>happstack-server</code> / <code>happstack-*</code> - \"Enterprise\" server frameworks with all the bells and whistles</li> <li><code>ihp</code> - batteries-included web framework with a friendly and helpful community. The best choice when getting started with haskell.</li> <li><code>servant</code> / <code>servant-*</code> - Library for type-safe REST servers and clients that might blow your mind</li> <li><code>graphql-api</code> - Implement a GraphQL API</li> <li><code>websockets</code> - Standalone websockets client and server</li> <li><code>authenticate</code> / <code>authenticate-*</code> - Shared authentication libraries</li> <li><code>ekg</code> / <code>ekg-*</code> - Haskell service monitoring</li> <li><code>stm</code> - Software-transactional memory</li> <li><code>lucid</code> - Haskell DSL for   building HTML</li> <li><code>mustache</code> / <code>karver</code> - Templating libraries</li> </ul>  Commentary <p>The main features in this category that Haskell brings to the table are:</p> <ul> <li>Server stability</li> <li>Performance</li> <li>Ease of concurrent programming</li> <li>Excellent support for web standards</li> </ul> <p>The strong type system and polished runtime greatly improve server stability and simplify maintenance.  This is the greatest differentiator of Haskell from other backend languages, because it significantly reduces the total-cost-of-ownership.  You should expect that you can maintain Haskell-based services with significantly fewer programmers than other languages, even when compared to other statically typed languages.</p> <p>The greatest weakness of server stability is space leaks.  The most common solution that I know of is to use <code>ekg</code> (a process monitor) to examine a server's memory stability before deploying to production.  The second most common solution is to learn to detect and prevent space leaks with experience, which is not as hard as people think.</p> <p>Haskell's performance is excellent and currently comparable to Java.  Both languages give roughly the same performance in beginner or expert hands, although for different reasons.</p> <p>Where Haskell shines in usability is the runtime support for the following three features:</p> <ul> <li>software transactional memory (which differentiates Haskell from Go)</li> <li>lightweight threads that use non-blocking I/O (which differentiates Haskell from the JVM)</li> <li>garbage collection (which differentiates Haskell from Rust)</li> </ul> <p>If you have never tried out Haskell's software transactional memory (STM), we highly recommend giving it a go, since it eliminates a large number of concurrency logic bugs.  STM is far and away the most underestimated feature of the Haskell runtime.</p> <p>Some web sites,services, and projects powered by Haskell:</p> <ul> <li>Facebook's spam filter: Sigma</li> <li>IMVU's REST API</li> <li>Utrecht's bicycle parking guidance system</li> <li>elm-lang.org</li> <li>glot.io</li> <li>The Perry Bible Fellowship</li> <li>Silk</li> <li>Shellcheck</li> <li>instantwatcher.com</li> <li>markup.rocks</li> <li>ZoomHub (Code)</li> <li>PostgREST - Generates a REST API for a Postgres database</li> <li>Hasura</li> <li>Mercury</li> </ul> <p>Success Stories:</p> <ul> <li>Fighting spam with Haskell - Haskell in production, at scale, at Facebook</li> <li>IMVU Engineering - What it's like to use Haskell</li> <li>Haskell-based Bicycle Parking Guidance System in Utrecht</li> <li>Mio: A High-Performance Multicore IO Manager for GHC</li> <li>The Performance of Open Source Applications - Warp</li> <li>Optimising Garbage Collection Overhead in Sigma</li> <li>instantwatcher.com author comments on rewrite from Ruby to Haskell - [1] [2]</li> <li>A lot of websockets in Haskell - A load test showing that a Haskell server can handle 500K connections in 10 GB of memory.  The load tester requires more resources than the server</li> </ul> <p>Educational resources:</p> <ul> <li>Beautiful concurrency - a software-transactional memory tutorial</li> <li>The Yesod book</li> <li>The Servant tutorial</li> <li>Overview of Happstack</li> <li>IHP Guide</li> <li>IHP Casts</li> </ul> <p>Notable hosting platforms:</p> <ul> <li>IHP Cloud</li> </ul>"},{"location":"packages/survey/#testing","title":"\ud83e\udd48 Testing","text":"<p>Notable libraries:</p> <ul> <li><code>QuickCheck</code> - property-based testing</li> <li><code>doctest</code> - tests embedded directly within documentation</li> <li><code>free</code> - Haskell's abstract version of \"dependency injection\"</li> <li><code>hspec</code> - Testing library analogous to Ruby's RSpec</li> <li><code>HUnit</code> - Testing library analogous to Java's JUnit</li> <li><code>tasty</code> - Combination unit / regression / property testing library</li> <li><code>hedgehog</code> - property-based testing with integrated shrinking</li> <li><code>HTF</code> - Preprocessor based unit testing with various output formats</li> </ul>  Commentary <p>There are a few places where Haskell is the clear leader among all languages:</p> <ul> <li>property-based testing</li> <li>mocking / dependency injection</li> </ul> <p>Haskell's <code>QuickCheck</code> is the gold standard which all other property-based testing libraries are measured against.  The reason <code>QuickCheck</code> works so smoothly in Haskell is due to Haskell's type class system and purity.  The type class system simplifies automatic generation of random data from the input type of the property test.  Purity means that any failing test result can be automatically minimized by rerunning the check on smaller and smaller inputs until <code>QuickCheck</code> identifies the corner case that triggers the failure.</p> <p>Haskell also supports most testing functionality that you expect from other languages, including:</p> <ul> <li>standard package interfaces for testing</li> <li>unit testing libraries</li> <li>test result summaries and visualization</li> </ul> <p>Educational resources:</p> <ul> <li>Why free monads matter</li> <li>Purify code using free monads</li> <li>Up-front Unit Testing in Haskell</li> </ul>"},{"location":"packages/survey/#data-structures-and-algorithms","title":"\ud83e\udd48 Data structures and algorithms","text":"<p>Notable libraries:</p> <ul> <li><code>vector</code> - High-performance arrays</li> <li><code>containers</code> - High-performance <code>Map</code>s, <code>Set</code>s, <code>Tree</code>s, <code>Graph</code>s, <code>Seq</code>s</li> <li><code>unordered-containers</code> - High-performance <code>HashMap</code>s, HashSets</li> <li><code>accelerate</code> / <code>accelerate-*</code> - GPU programming</li> <li><code>massiv</code> / <code>repa</code> / <code>repa-*</code> - parallel shape-polymorphic arrays</li> <li><code>discrimination</code> - Efficient linear-time sorting for user-defined datatypes</li> <li><code>algebraic-graphs</code></li> </ul>  Commentary <p>Haskell primarily uses persistent data structures, meaning that when you \"update\" a persistent data structure you just create a new data structure and you can keep the old one around (thus the name: persistent).  Haskell data structures are immutable, so you don't actually create a deep copy of the data structure when updating; any new structure will reuse as much of the original data structure as possible.</p> <p>The Notable libraries sections contains links to Haskell collections libraries that are heavily tuned.  You should realistically expect these libraries to compete with tuned Java code.  However, you should not expect Haskell to match expertly tuned C++ code.</p> <p>The selection of algorithms is not as broad as in Java or C++ but it is still pretty good and diverse enough to cover the majority of use cases.</p>"},{"location":"packages/survey/#benchmarking","title":"\ud83e\udd48 Benchmarking","text":"<p>Notable libraries:</p> <ul> <li><code>criterion</code></li> <li><code>gauge</code> offers a similar feature set as <code>criterion</code> but has much fewer dependencies</li> <li><code>tasty-bench</code> even lighter than <code>gauge</code> with support for comparing benchmarks</li> </ul>  Commentary <p>This boils down exclusively to the <code>criterion</code> library, which was done so well that nobody bothered to write a competing library.  Notable <code>criterion</code> features include:</p> <ul> <li>Detailed statistical analysis of timing data</li> <li>Beautiful graph output: (Example)</li> <li>High-resolution analysis (accurate down to nanoseconds)</li> <li>Customizable HTML/CSV/JSON output</li> <li>Garbage collection insensitivity</li> </ul> <p>Educational resources:</p> <ul> <li>The <code>criterion</code> tutorial</li> </ul>"},{"location":"packages/survey/#unicode","title":"\ud83e\udd48 Unicode","text":"<p>Notable libraries:</p> <ul> <li><code>text</code></li> <li><code>text-icu</code></li> <li><code>unicode-transforms</code> \u2013 Unicode normalization</li> </ul>  Commentary <p>Haskell's Unicode support is excellent.  Just use the <code>text</code> and <code>text-icu</code> libraries, which provide a high-performance, space-efficient, and easy-to-use API for Unicode-aware text operations.</p> <p>Note that there is one big catch: the default <code>String</code> type in Haskell is inefficient.  You should always use <code>Text</code> whenever possible.</p>"},{"location":"packages/survey/#stream-programming","title":"\ud83e\udd48 Stream programming","text":"<p>Notable libraries:</p> <ul> <li><code>conduit</code> / <code>io-streams</code> / <code>pipes</code> / <code>streaming</code> / <code>streamly</code> - Stream programming libraries</li> <li><code>machines</code> - Networked stream transducers library</li> </ul>  Commentary <p>Haskell's streaming ecosystem is mature.  Probably the biggest issue is that there are too many good choices (and a lot of ecosystem fragmentation as a result), but each of the streaming libraries listed below has a sufficiently rich ecosystem including common streaming tasks like:</p> <ul> <li>Network transmissions</li> <li>Compression</li> <li>External process pipes</li> <li>High-performance streaming aggregation</li> <li>Concurrent streams</li> <li>Incremental parsing</li> </ul> <p>Educational resources:</p> <ul> <li>The official <code>streamly</code> manual</li> <li>The official <code>conduit</code> tutorial</li> <li>The official <code>pipes</code> tutorial</li> <li>The official <code>io-streams</code> tutorial</li> <li>A benchmark of popular streaming libraries</li> </ul>"},{"location":"packages/survey/#serialization","title":"\ud83e\udd48 Serialization","text":"<p>Notable libraries:</p> <ul> <li><code>binary</code> / <code>cereal</code> / <code>serialise</code> / <code>store</code> - serialization / deserialization libraries</li> </ul>  Commentary <p>Haskell's serialization libraries are reasonably efficient and very easy to use.  You can easily automatically derive serializers/deserializers for user-defined data types and it's very easy to encode/decode values.</p> <p>Haskell's serialization does not suffer from any of the gotchas that object-oriented languages deal with (particularly Java/Scala).  Haskell data types don't have associated methods or state to deal with so serialization/deserialization is straightforward and obvious.  That's also why you can automatically derive correct serializers/deserializers.</p> <p>Serialization performance is pretty good.  You should expect to serialize data at a rate between 100 Mb/s to 1 Gb/s with careful tuning.  Serialization performance still has about 3x-5x room for improvement by multiple independent estimates.  See the \"Faster binary serialization\" link below for details of the ongoing work to improve the serialization speed of existing libraries.</p> <p>Educational resources:</p> <ul> <li>Benchmarks of several popular serialization libraries</li> <li>Faster binary serialization / Better, faster binary serialization - Slides on serialization efficiency improvements</li> </ul>"},{"location":"packages/survey/#ide-support","title":"\ud83e\udd48 IDE support","text":"<p>The Haskell Language Server provides IDE support for editors which support Microsoft's Language Service Protocol (LSP). The easiest of these to use is VSCode, but other choices like vim will work.</p> <p>The Haskell Language Server is included as part of Haskell's installer, GHCup.</p>"},{"location":"packages/survey/#support-for-file-formats","title":"\ud83e\udd48 Support for file formats","text":"<p>Notable libraries:</p> <ul> <li><code>aeson</code> - JSON encoding/decoding</li> <li><code>cassava</code> / <code>sv</code>- CSV encoding/decoding</li> <li><code>yaml</code> - YAML encoding/decoding</li> <li><code>HsYAML</code> - pure Haskell YAML 1.2 parser</li> <li><code>xml</code> - XML encoding/decoding</li> <li><code>tomland</code> - TOML encoding/decoding</li> </ul>  Commentary <p>Haskell supports all the common domain-independent serialization formats (i.e. XML/JSON/YAML/CSV).  For more exotic formats Haskell won't be as good as, say, Python (which is notorious for supporting a huge number of file formats) but it's so easy to write your own quick and dirty parser in Haskell that this is not much of an issue.</p>"},{"location":"packages/survey/#logging","title":"\ud83e\udd48 Logging","text":"<ul> <li><code>fast-logger</code> - High-performance multicore logging system</li> <li><code>hslogger</code> - Logging library analogous to Python's <code>logging</code> library</li> <li><code>monad-logger</code> - add logging with line numbers to your monad stack. Uses fast-logger under the hood.</li> <li><code>katip</code> - Structured logging</li> <li><code>log</code> - Logging system with ElasticSearch, PostgreSQL and stdout sinks.</li> <li><code>co-log</code> - Composable contravariant comonadic logging library.</li> </ul>"},{"location":"packages/survey/#code-formatting","title":"\ud83e\udd48 Code formatting","text":"<p>Haskell has tools for automatic code formatting:</p> <ul> <li><code>ormolu</code> - More opinionated formatting tool that uses GHC's own parser</li> <li><code>fourmolu</code> - like <code>ormolu</code> but with configurability</li> <li><code>stylish-haskell</code> - Less opinionated code formatting tool that mostly formats imports, language extensions, and data type definitions</li> </ul>"},{"location":"packages/survey/#scripting","title":"\ud83e\udd48 Scripting","text":"<p>Notable libraries:</p> <ul> <li><code>shelly</code> / <code>turtle</code> / <code>shellmet</code> - scripting libraries</li> <li><code>optparse-applicative</code> / <code>cmdargs</code> - command-line argument parsing</li> <li><code>haskeline</code> - a complete Haskell implementation of <code>readline</code> for console   building</li> <li><code>process</code> - low-level library for sub-process management</li> <li><code>ansi-terminal</code> - de facto standard cross-platform terminal library (works on Windows as well)</li> <li><code>brick</code> - terminal user interfaces (TUIs)</li> <li><code>path</code> / <code>path-io</code> - type safe handling of file paths</li> <li><code>http-client</code> / <code>http-client-*</code> / <code>req</code> / <code>req-*</code> / <code>wreq</code> - HTTP clients</li> </ul>  Commentary <p>Haskell's biggest advantage as a scripting language is that Haskell is the most widely adopted language that supports global type inference.  Many languages support local type inference (such as Rust, Go, Java, C#), which means that function argument types and interfaces must be declared but everything else can be inferred.  In Haskell, you can omit everything: all types and interfaces are completely inferred by the compiler (with some caveats, but they are minor).</p> <p>Global type inference gives Haskell the feel of a scripting language while still providing static assurances of safety.  Script type safety matters in particular for enterprise environments where glue scripts running with elevated privileges are one of the weakest points in these software architectures.</p> <p>The second benefit of Haskell's type safety is ease of script maintenance. Many scripts grow out of control as they accrete arcane requirements and once they begin to exceed 1000 LOC they become difficult to maintain in a dynamically typed language.  People rarely budget sufficient time to create a sufficiently extensive test suite that exercises every code path for each and every one of their scripts.  Having a strong type system is like getting a large number of auto-generated tests for free that exercise all script code paths.  Moreover, the type system is more resilient to refactoring than a test suite.</p> <p>However, the language is also usable even for simple one-off disposable scripts.  These Haskell scripts are comparable in size and simplicity to their equivalent Bash or Python scripts. This lets you easily start small and finish big.</p> <p>Haskell has one advantage over many dynamic scripting languages, which is that Haskell can be compiled into a native and statically linked binary for distribution to others.</p> <p>Haskell's scripting libraries are feature complete and provide all the niceties that you would expect from scripting in Python or Ruby, including features such as:</p> <ul> <li>rich suite of Unix-like utilities</li> <li>advanced sub-process management</li> <li>POSIX support</li> <li>light-weight idioms for exception safety and automatic resource disposal</li> </ul> <p>Some command-line tools written in Haskell:</p> <ul> <li><code>pandoc</code></li> <li><code>git-annex</code></li> <li><code>hledger</code></li> </ul> <p>Educational resources:</p> <ul> <li>Shelly: Write your shell scripts in Haskell</li> <li>Use Haskell for shell scripting</li> </ul>"},{"location":"packages/survey/#data-science","title":"\ud83c\udf31 Data science","text":"<p>Notable libraries:</p> <ul> <li><code>diagrams</code> / <code>diagrams-*</code> - Vector graphics library</li> <li><code>ihaskell</code> - Haskell backend to IPython</li> <li><code>hmatrix</code> - BLAS / LAPACK wrapper</li> <li><code>HaskellR</code> - Mix Haskell and R code in Jupyter notebooks</li> <li><code>Sparkle</code> - Haskell-to-Spark bridge</li> <li><code>cassava</code> - CSV encoding and decoding</li> <li><code>Frames</code> - Haskell data analysis tool analogous to Python's <code>pandas</code></li> <li><code>statistics</code></li> <li><code>hvega</code> - Plots via JS: quite powerful and well documented</li> <li><code>Chart</code> / <code>Chart-*</code> - Charting library</li> </ul>  Commentary <p>Haskell data science can take advantage of other data science ecosystems via the <code>HaskellR</code> and <code>Sparkle</code> projects. <code>HaskellR</code> is a Haskell-to-R bridge with Jupyter notebook integration, which lets you take advantage of the broad R ecosystem while benefiting from the speed and type safety of Haskell.  <code>Sparkle</code> is a Haskell-to-Spark bridge which lets you interface with the Spark subset of the Java/Scala data science ecosystem. However, to get a Mature rating Haskell data science needs to be able to stand alone without depending on other programming language ecosystems.</p> <p>If you restrict yourself to just the Haskell ecosystem then choices are more limited. </p> <p>The Haskell analog of Python's <code>NumPy</code> is the <code>hmatrix</code> library, which provides Haskell bindings to BLAS, LAPACK.  <code>hmatrix</code>'s main limitation is that the API is a bit clunky, but all the tools are there.</p> <p>Haskell's charting story is okay.  Most charting APIs tend to be large, the types are a bit complex, and they have a very large number of dependencies.</p> <p>Fortunately, Haskell does integrate into IPython so you can use Haskell within an IPython shell or an online notebook.  For example, there is an online \"IHaskell\" notebook that you can use right now located here:</p> <ul> <li>IHaskell notebook - Click on \"Welcome to Haskell.ipynb\"</li> </ul> <p>If you want to learn more about how to setup your own IHaskell notebook, visit this project:</p> <ul> <li>IHaskell Github repository</li> </ul> <p>The closest thing to Python's <code>pandas</code> is the <code>frames</code> library.</p> <p>One Haskell library that deserves honorable mention here is the <code>diagrams</code> library which lets you produce complex data visualizations very easily if you want something a little bit fancier than a chart.  Check out the <code>diagrams</code> project if you have time:</p> <ul> <li>The Diagrams project</li> <li>Gallery of example diagrams</li> </ul> <p>Areas for improvement:</p> <ul> <li>Smooth user experience and integration across all of these libraries</li> <li>Simple types and APIs.  The data science programmers I know dislike overly complex or verbose APIs</li> <li>Beautiful data visualizations with very little investment</li> </ul>"},{"location":"packages/survey/#numerical-programming","title":"\ud83c\udf31 Numerical programming","text":"<p>Notable libraries:</p> <ul> <li><code>accelerate</code> / <code>accelerate-*</code> - GPU programming</li> <li><code>vector</code> - high-performance arrays</li> <li><code>massiv</code> / <code>repa</code> / <code>repa-*</code> - parallel shape-polymorphic arrays</li> <li><code>hmatrix</code> / <code>hmatrix-*</code> - Haskell's BLAS / LAPACK wrapper</li> <li><code>ad</code> - automatic differentiation</li> </ul>  Commentary <p>Haskell's numerical programming story is not ready, but steadily improving.</p> <p>The biggest issues that the ecosystem faces are:</p> <ul> <li>Really clunky matrix library APIs</li> <li>Fickle rewrite-rule-based optimizations</li> </ul> <p>When the optimizations work they are amazing and produce code competitive with C.  However, small changes to your code can cause the optimizations to suddenly not trigger and then performance drops off a cliff.</p> <p>There is one Haskell library that avoids this problem entirely: <code>accelerate</code> generates LLVM and CUDA code at runtime and does not rely on Haskell's optimizer for code generation, which side-steps the problem.  <code>accelerate</code> has a large set of supported algorithms that you can find by just checking the library's reverse dependencies:</p> <ul> <li>Reverse dependencies of <code>accelerate</code></li> </ul> <p>Success Stories:</p> <ul> <li>Exploiting vector instructions with generalized stream fusion</li> <li>Type-safe Runtime Code Generation: Accelerate to LLVM</li> </ul> <p>Educational Resources:</p> <ul> <li>Parallel and concurrent programming in Haskell</li> </ul>"},{"location":"packages/survey/#front-end-web-programming","title":"\ud83c\udf31 Front-end web programming","text":"<p>Notable libraries:</p> <ul> <li>reflex / reflex-dom - Functional reactive programming library   for the front end</li> <li>miso a small \"isomorphic\" front-end framework featuring a virtual-dom, inspired by Elm, Redux and Bobril.</li> </ul>  Commentary <p>This boils down to Haskell's ability to compile to JavaScript and WASM. Upcoming GHC versions will allow compilation to both, but for now the technology is experimental.</p> <p>There are two Haskell-like languages for front-end programming: <code>elm</code> and <code>purescript</code>. These are both used in production today and have equally active maintainers and communities of their own.  <code>purescript</code> in particular is extremely similar to Haskell.</p> <p>Areas for improvement:</p> <ul> <li>lack of clear story for smooth integration with existing JavaScript projects</li> <li>lack of educational resources targeted at non-experts explaining how to translate existing front-end programming idioms to Haskell</li> <li>lack of well-maintained and polished Haskell libraries for front-end programming</li> <li>lack of documentation for <code>ghcjs</code> ecosystem.  There's not even a basic tutorial on how to actually use <code>ghcjs</code></li> </ul> <p>Notable Haskell-to-JavaScript compilers:</p> <ul> <li><code>ghcjs</code></li> <li><code>haste</code></li> </ul>"},{"location":"packages/survey/#distributed-programming","title":"\ud83c\udf31 Distributed programming","text":"<p>Notable libraries:</p> <ul> <li><code>glue-core</code> /   <code>glue-ekg</code> /   <code>glue-example</code> - Service toolkit supporting</li> <li><code>haxl</code> - Facebook library for   efficient batching and scheduling of concurrent data access</li> <li><code>distributed-process</code> / <code>distributed-process-*</code> - Haskell analog to Erlang</li> <li><code>hadron</code> - Haskell wrapper around <code>hadoop</code></li> <li><code>amazonka</code> / <code>amazonka-*</code> - Auto-generated   bindings to the entire Amazon Web Services SDK</li> <li><code>gogol</code> / <code>gogol-*</code> - Auto-generated bindings to the entire Google Cloud Platform</li> <li><code>transient</code> - composable primitives for concurrency / parallelism / distributed computing</li> </ul>  Commentary <p>For distributed service architectures Haskell is catching up to its peers with service toolkit libraries, but for distributed computation Haskell still lags behind.</p> <p>There has been a lot of work in replicating Erlang-like functionality in Haskell through the Cloud Haskell project, not just in creating the low-level primitives for code distribution / networking / transport, but also in assembling a Haskell analog of Erlang's OTP.  Work on the higher-level libraries seems to have stopped, but the low-level libraries are still good for distributing computation.</p> <p>Areas for improvement:</p> <ul> <li>More analytics libraries needed.  Haskell has no analog of <code>scalding</code> or <code>spark</code>.  The most we have is just a Haskell wrapper around <code>hadoop</code></li> <li>A polished consensus library (i.e. a high quality Raft implementation in Haskell) needed.</li> </ul>"},{"location":"packages/survey/#standalone-gui-applications","title":"\ud83c\udf31 Standalone GUI applications","text":"<p>Notable libraries:</p> <ul> <li><code>brick</code> - Terminal UI based on vty package</li> <li><code>threepenny-gui</code> - Framework for local apps that use the web browser as the interface</li> <li><code>gi-gtk</code> and various other bindings such as GStreamer audio/video - GTK+ (and more generally, GObject) bindings done right (autogenerated using GObject Introspection, hence <code>gi</code>)</li> <li><code>wx</code> - wxWidgets bindings</li> <li><code>X11</code> - X11 bindings</li> <li><code>hsqml</code> - A Haskell binding for Qt Quick, a cross-platform framework for creating graphical user interfaces.</li> <li><code>fltkhs</code> - A Haskell binding to FLTK. Easy install/use, cross-platform, self-contained executables.</li> <li><code>FregeFX</code> - Frege bindings to Java FX   (Frege is essentially the Haskell for the JVM)</li> <li><code>typed-spreadsheet</code> -   Library for building composable interactive forms</li> </ul>  Commentary <p>Most Haskell GUI libraries are wrappers around toolkits written in other languages (such as GTK+ or Qt).  However, the Haskell bindings to GTK+ have a strongly imperative feel to them. The way you do everything is communicating between callbacks by mutating <code>IORef</code>s.  Also, you can't take extensive advantage of Haskell's awesome threading features because the GTK+ runtime is picky about what needs to happen on certain threads. </p> <p>There still isn't a Haskell binding to a widget toolkit that doesn't have some sort of setup issues with the toolkit.</p> <p>My impression is that most Haskell programmers interested in applications programming have collectively decided to concentrate their efforts on improving Haskell web applications instead of standalone GUI applications.  Honestly, that's probably the right decision in the long run.</p> <p>Another post that goes into more detail about this topic is this post written by Keera Studios:</p> <ul> <li>On the state of GUI programming in Haskell</li> </ul> <p>Areas for improvement:</p> <ul> <li>A GUI toolkit binding that is maintained, comprehensive, and easy to use</li> <li>Polished GUI interface builders</li> </ul> <p>Some example applications:</p> <ul> <li><code>xmonad</code></li> <li><code>leksah</code></li> </ul> <p>Educational resources:</p> <ul> <li>Haskell port of the GTK tutorial</li> <li>Building pragmatic user interfaces in Haskell with HsQML</li> <li>FLTK GUIs, including support for the Fluid visual interface builder</li> </ul>"},{"location":"packages/survey/#machine-learning","title":"\ud83c\udf31 Machine learning","text":"<p>Notable libraries:</p> <ul> <li><code>hasktorch</code> - Haskell bindings to   libtorch which is the C++ API for PyTorch</li> <li><code>ad</code> - Automatic differentiation,   used as a substrate for many Haskell machine learning projects</li> <li><code>backprop</code> - AD for heterogenous types</li> <li><code>ad-delcont</code></li> <li><code>grenade</code> - Machine learning   library implemented in Haskell with a BLAS/LAPACK backend and a high-level   type-based API</li> <li><code>tensorflow</code> - Haskell bindings to   Google's <code>tensorflow</code> project</li> <li><code>arrayfire</code> - Haskell bindings to   ArrayFire</li> </ul>  Commentary <p>There are two approaches to using machine learning in Haskell:</p> <ul> <li>Use a Haskell binding to an implementation in another language</li> <li>Use a machine learning library implemented in Haskell</li> </ul> <p>You will most likely want to check out Haskell bindings to the <code>libtorch</code> library if you are interested in the first approach.</p> <p>Also, Tweag.io has released <code>Sparkle</code>, a Haskell integration with Spark.  This enables the use of MLib from Haskell.  MLib is widely used in the industry for machine learning. Sparkle itself is fairly new.</p> <ul> <li>Github repository for <code>Sparkle</code></li> </ul>"},{"location":"packages/survey/#game-programming","title":"\ud83c\udf31 Game programming","text":"<p>Notable libraries:</p> <ul> <li><code>gloss</code> - Simple graphics and   game programming for beginners</li> <li><code>Yampa</code> - A reactive programming library which has been used to implement games in a reactive style</li> <li>Code World - Similar to <code>gloss</code>, but you can try   it in your browser</li> <li><code>vulkan</code> - Low-level Vulkan bindings</li> <li><code>gl</code> - Comprehensive OpenGL bindings</li> <li><code>SDL</code> / <code>SDL-*</code> / <code>sdl2</code> - Bindings to the SDL library</li> <li><code>SFML</code> - Bindings to the SFML library</li> <li><code>quine</code> - Github project with cool 3D demos</li> <li><code>GPipe</code> - Type-safe OpenGL API   that also lets you embed shader code directly within Haskell.  See the   GPipe wiki to learn more</li> </ul>  Commentary <p>Haskell is a garbage collected language, so Haskell is more appropriate for the scripting / logic layer of a game but not suitable manipulating a large object graph or for implementing a high-performance game engine due to the risk of introducing perceptible pauses due to GC pauses.  For simple games you can realistically use Haskell for the entire stack.</p> <p>Examples of games that could be fully implemented in Haskell:</p> <ul> <li>Casual games</li> <li>Turn-based strategy games</li> <li>Adventure games</li> <li>Platform / side-scrolling games</li> <li>First-person shooter</li> </ul> <p>Examples of games that are difficult to implement at all in Haskell:</p> <ul> <li>Real-time strategy games</li> <li>MMORPGs</li> </ul> <p>Haskell has SDL, OpenGL, and Vulkan bindings, which are actually quite good, but that's about it.  You're on your own from that point onward.  There is not a rich ecosystem of higher-level libraries built on top of those bindings.  There is some work in this area, but nothing production quality or easy to use.</p> <p>The primary reason for the immature rating is the difficulty of integrating Haskell with existing game platforms, which often are biased towards a particular language or toolchain.  The only game platform where Haskell has no issues is native binaries for desktop games.  For the web, you must compile to JavaScript, which is doable.  For mobile games on Android you have to cross compile and interface the Haskell logic with Android through JNI + Haskell's foreign function interface.  For console games, you have no hope.</p> <p>Areas for improvement:</p> <ul> <li>Improve the garbage collector and benchmark performance with large heap sizes</li> <li>Provide higher-level game engines</li> <li>Improve distribution of Haskell games on proprietary game platforms</li> </ul> <p>Educational resources:</p> <ul> <li>Purely Functional Games</li> </ul>"},{"location":"packages/survey/#arm-processor-support","title":"\ud83c\udf31 ARM processor support","text":"Commentary <p>On hobbyist boards like the Raspberry Pi its possible to compile Haskell code with GHC.  There are limitations; some libraries have problems on the arm platform, and GHCi only works on newer compilers.  Cross compiling doesn't work with template Haskell.  Stack and other large projects can take more than 1g of memory to compile.</p> <p>However, if the Haskell code builds, it runs with respectable performance on these machines.</p> <p>Arch (Banana Pi)</p> <p>update 2016-02-25:</p> <ul> <li>installed today from pacman, current versions are GHC 7.10.3 and cabal-install 1.22.6.0</li> <li>a compatible version of llvm also installed automatically.</li> <li>GHCi passes hello world test; cabal/GHC compiled a modest project normally.</li> </ul> <p>Raspian (Raspberry Pi, pi2, others)</p> <ul> <li>current version: GHC 7.4, cabal-install 1.14</li> <li>GHCi doesn't work.</li> </ul> <p>Debian Jesse (Raspberry Pi 3)</p> <ul> <li>works with: <code>ghc-7.10.3</code> and <code>stack-1.1.2</code></li> <li>Requires <code>llvm</code> version 3.5.2 or higher.  Do not use the <code>llvm-3.5</code> provided by default in the Jessie package distribution</li> </ul> <p>Arch (Raspberry Pi 2)</p> <ul> <li>current version 7.8.2, but llvm is 3.6, which is too new.</li> <li>downgrade packages for llvm not officially available.</li> <li>with llvm downgrade to 3.4, GHC and GHCi work, but problems compiling yesod, scotty.</li> <li>compiler crashes, segfaults, etc.</li> </ul>"},{"location":"packages/survey/#computer-vision","title":"\ud83c\udf31 Computer Vision","text":"<p>Notable libraries:</p> <ul> <li><code>haskell-opencv</code></li> <li><code>HOpenCV</code></li> <li><code>HOpenCV</code> fork</li> <li><code>easyVision</code></li> <li><code>cv-combinators</code></li> <li><code>Zef</code></li> </ul>  Commentary <p>The largest real world Haskell usage of computer vision is LumiGuide, which powers municipal bicycle detection and guidance systems in Amsterdam.  They maintain <code>OpenCV</code> bindings in their <code>haskell-opencv</code> library.</p> <p>There are some interesting projects which try to tackle computer vision in a purely functional manner. <code>cv-combinators</code>, <code>easyVision</code>, and <code>Zef</code> are some examples.</p> <p>There are Haskell bindings for OpenCV available via <code>HOpenCV</code> which has bindings for versions up to <code>OpenCV 2.0</code>. A fork maintained by Anthony Cowley has bindings available for versions up to <code>OpenCV 2.4</code>, but it pretty much stops there. Currently, <code>OpenCV 3.0</code> has been released, and there are no Haskell bindings covering it.</p> <p>Success Stories:</p> <ul> <li>Google TechTalk on LumiGuide</li> </ul>"},{"location":"packages/survey/#mobile-apps","title":"\ud83c\udf31 Mobile apps","text":"Commentary <p>This greatly lags behind using languages that are natively supported by the mobile platform (i.e. Java for Android or Objective-C / Swift for iOS).</p> <p>However, one route is to compile Haskell to a supported language.  For example, you can compile Haskell to Java using Eta to port Haskell games to Android.</p> <p>Educational resources:</p> <ul> <li>Android 2048 game in Eta</li> <li>Android development in Haskell</li> <li>iPhone development in Haskell</li> </ul>"},{"location":"packages/survey/#databases-and-data-stores","title":"\ud83c\udf31 Databases and data stores","text":"<p>Notable libraries:</p> <ul> <li><code>mysql-haskell</code> / <code>mysql-simple</code> - MySQL bindings</li> <li><code>postgresql-simple</code> - Postgres bindings</li> <li><code>persistent</code> - Database-agnostic ORM that supports automatic migrations</li> <li><code>esqueleto</code> / <code>relational-record</code> / <code>opaleye</code> - type-safe APIs for building well-formed SQL queries</li> <li><code>acid-state</code> - Simple ACID data store that saves Haskell data types natively</li> <li><code>aws</code> - Bindings to Amazon DynamoDB</li> <li><code>hedis</code> - Bindings to Redis</li> <li><code>groundhog</code> - A nice datatype to relational mapping library, similar to ORMs</li> <li><code>hasql</code> - An efficient PostgreSQL driver and a flexible mapping API based on the binary protocol</li> </ul>  Commentary <p>The \"Immature\" ranking is based on the lack of bindings to commercial databases like Microsoft SQL server and Oracle.  So whether or not Haskell is right for you probably depends heavily on whether there are bindings to the specific data store you use.</p>"},{"location":"packages/survey/#debugging","title":"\ud83c\udf31 Debugging","text":"<p>Educational resources:</p> <ul> <li>GHC Manual - Profiling chapter - Read the whole thing; you will thank me   later</li> <li>Debugging runtime options - See the <code>+RTS -xc</code> flag which adds stack traces to all exceptions (requires profiling enabled)</li> <li><code>GHC.Stack</code> - Programmatic access to the call stack</li> <li>Pinpointing space leaks in big programs</li> <li>Real World Haskell - Profiling and Optimization</li> <li>The GHCi Debuggger - Manual for GHCi-based breakpoints and   single-stepping</li> <li>Parallel and Concurrent Programming in Haskell - Debugging, Tuning, and Interfacing with Foreign Code - Debugging concurrent programs</li> <li>Haskell wiki - ThreadScope</li> </ul>  Commentary <p>The main Haskell debugging features are:</p> <ul> <li>Memory and performance profiling</li> <li>Stack traces</li> <li>Source-located errors, using the <code>assert</code> function</li> <li>Breakpoints, single-stepping, and tracing within the GHCi REPL</li> <li>Informal <code>printf</code>-style tracing using <code>Debug.Trace</code></li> <li>ThreadScope</li> </ul>"},{"location":"packages/survey/#hot-code-loading","title":"\ud83c\udf31 Hot code loading","text":"<p>Notable libraries:</p> <ul> <li><code>essence-of-live-coding</code></li> <li><code>dyre</code> / <code>halive</code> - Program reinitialization with saved state</li> <li><code>rapid</code> - Code reloading within   <code>ghci</code> that persists state across reloads</li> <li><code>plugins</code> / <code>hint</code> - Runtime compilation and linking</li> </ul>"},{"location":"packages/survey/#systems-embedded-programming","title":"\ud83c\udf31 Systems / embedded programming","text":"<p>Educational resources:</p> <ul> <li>Retrocomputing with Clash</li> <li>/r/haskell - Haskell compiled down to Embedded Hardware</li> </ul>  Commentary <p>Systems programming here means: programs where speed, memory layout, and latency really matter.</p> <p>Haskell fares really poorly in this area because:</p> <ul> <li>The language is garbage collected, so there are no latency guarantees</li> <li>Executable sizes are large</li> <li>Memory usage is difficult to constrain (thanks to space leaks)</li> <li>Haskell has a large and unavoidable runtime, which means you cannot easily embed Haskell within larger programs</li> <li>You can't easily predict what machine code that Haskell code will compile to</li> </ul> <p>Typically people approach this problem from the opposite direction: they write the low-level parts in C or Rust and then write Haskell bindings to the low-level code.</p> <p>It's worth noting that there is an alternative approach which is Haskell DSLs that are strongly typed that generate low-level code at runtime.  This is the approach championed by the company Galois.</p> <p>Notable libraries:</p> <ul> <li><code>copilot</code> - Stream DSL that generates C code</li> <li><code>atom</code> / <code>ivory</code> - DSL for generating embedded programs</li> <li><code>improve</code> - High-assurance DSL for embedded code that generates C and Ada</li> </ul>"},{"location":"resources/articles/","title":"Articles","text":"<p>There is a variety of great articles written by Haskellers on all sorts of intermediate and advanced topics. See here for an overview of popular blogs.</p>"},{"location":"resources/articles/#industry-haskell","title":"Industry Haskell","text":"<p>Interviews with industry Haskell projects</p>"},{"location":"resources/articles/#for-newcomers","title":"For newcomers","text":""},{"location":"resources/articles/#why-haskell","title":"Why Haskell?","text":"<p>Edward Kmett's opinion (on Quora)</p>"},{"location":"resources/articles/#types","title":"Types","text":"<p>Parse, don't validate</p> <p>How to think about types</p>"},{"location":"resources/articles/#purity","title":"Purity","text":"<p>Equational reasoning</p>"},{"location":"resources/articles/#idiomatic-haskell","title":"Idiomatic Haskell","text":"<p>Style guide</p> <p>Naming conventions</p>"},{"location":"resources/articles/#syntax","title":"Syntax","text":"<p>Overview</p>"},{"location":"resources/articles/#for-intermediate-haskellers","title":"For Intermediate Haskellers","text":""},{"location":"resources/articles/#laziness-and-performance","title":"Laziness and performance","text":"<p>An old but classic article on laziness and modularity</p> <p>A guide to lazy evaluation, with sections on time and space performance.</p> <p>The Haskell wiki on laziness</p>"},{"location":"resources/articles/#recursion-and-recursive-types","title":"Recursion and recursive types","text":"<p>A tour of some useful recursive types</p> <p>Mergesort example with recursion schemes</p> <p>A series on recursion schemes:</p> <ul> <li>Motivating recursion schemes</li> <li>Basic recursion schemes (catamorphism)</li> <li>More powerful recursion schemes (paramorphism)</li> <li>Even more powerful recursion schemes (histomorphism)</li> </ul> <p>Another nice introduction to recursion schemes</p> <p>Another kind of recursion scheme (prepromorphism)</p>"},{"location":"resources/articles/#testing-profiling-and-benchmarking","title":"Testing, profiling and benchmarking","text":"<p>Property based tests</p> <p>Unit tests</p> <p>Benchmarking</p>"},{"location":"resources/articles/#algorithms-and-data-structures","title":"Algorithms and data structures","text":"<p>Common data structures</p> <p>Efficient queues</p> <p>Finger trees</p>"},{"location":"resources/articles/#web","title":"Web","text":"<p>Databases and servers</p> <p>A web framework</p>"},{"location":"resources/articles/#the-type-system","title":"The type system","text":"<p>Type level programming</p> <p>Dependent types</p>"},{"location":"resources/articles/#typeclasses","title":"Typeclasses","text":"<p>Typeclass metaprogramming</p>"},{"location":"resources/articles/#exceptions","title":"Exceptions","text":"<p>Exceptions</p>"},{"location":"resources/articles/#miscellaneous","title":"Miscellaneous","text":"<p>Comonads</p>"},{"location":"resources/articles/#advanced-level-resources","title":"Advanced level resources","text":""},{"location":"resources/articles/#compilation","title":"Compilation","text":"<p>Inlining</p> <p>GHC</p> <p>JIT compilation</p> <p>Implementing variable binding</p>"},{"location":"resources/articles/#algorithms-and-data-structures_1","title":"Algorithms and data structures","text":"<p>The codensity monad optimization</p> <p>Articles by Ed Kmett1:</p> <ul> <li>Parsing</li> <li>Lowest common ancestor</li> <li>Moore machines</li> <li>Automata</li> <li>Deamortization</li> </ul>"},{"location":"resources/articles/#template-haskell-metaprogramming","title":"Template Haskell (metaprogramming)","text":"<p>Intro to Template Haskell</p> <p>Tutorial on Template Haskell</p>"},{"location":"resources/articles/#for-developers","title":"For Developers","text":""},{"location":"resources/articles/#writing-documentation","title":"Writing documentation","text":"<p>Using Haddock</p> <p>Stack vs Cabal</p> <p>Nix</p>"},{"location":"resources/articles/#advice-on-large-projects","title":"Advice on large projects","text":"<p>Reflections on Haskell in production</p>   <ol> <li> <p>Ed Kmett is a hugely prolific Haskell library contributor. His libraries tend to be aimed to more advanced users, and to lean into Haskell's capabilities to write very general abstract code.\u00a0\u21a9</p> </li> </ol>"},{"location":"resources/books/","title":"Books","text":"<p>This is a small selection of the wide range of books on Haskell.</p>"},{"location":"resources/books/#books-aimed-at-newcomers-to-haskell","title":"Books aimed at newcomers to Haskell","text":"<p>Practical Haskell: A Real World Guide to Programming</p> <p>Haskell Programming from first principles</p>"},{"location":"resources/books/#books-for-intermediate-users","title":"Books for intermediate users","text":"<p>Parallel and Concurrent Programming in Haskell</p> <p>Haskell (almost) Standard Libraries</p>"},{"location":"resources/books/#books-for-advanced-users","title":"Books for advanced users","text":"<p>Purely functional data structures</p> <p>Thinking functionally with Haskell</p>"},{"location":"resources/resources/","title":"Overview","text":""},{"location":"resources/resources/#for-newcomers","title":"For newcomers","text":"<p>These notes are a widely used introduction to Haskell.</p> <p>Learn You a Haskell is a friendly introductory book, with an interactive notebook version.</p> <p>This Youtube series is a popular video tutorial for Haskell.</p>"},{"location":"resources/resources/#project-based-learning","title":"Project-based learning","text":"<p>Learn Haskell by building a blog generator is a free book that takes a project-based approach to learning Haskell.</p>"},{"location":"resources/resources/#community","title":"Community","text":"<p>Haskell has an active subreddit with a dedicated section for questions.</p> <p>It also has its own forum.</p>"},{"location":"resources/resources/#understanding-the-ecosystem","title":"Understanding the ecosystem","text":"<p>This package overview is very useful for quickly understanding what Haskell packages to use for what tasks.</p> <p>haskell-links.org presents links from #haskell IRC/Matrix chatters, with a fast search interface.</p>"},{"location":"resources/resources/#more-advanced-resources","title":"More advanced resources","text":"<p>This reference guide/tutorial carefully and clearly details important advanced concepts and features in Haskell.</p> <p>This performance guide explains how to engineer programs in Haskell to be as fast as possible.</p> <p>The Haskell report is an exhaustive and carefully written reference manual of all of Haskell.</p>"},{"location":"resources/resources/#friendly-libraries","title":"Friendly libraries","text":"<p>pipes is a useful library for streaming which has very friendly documentation including a tutorial. This is a good library to understand how to think functionally, and how to use monads practically.</p> <p>foldl is a beautifully documented library for writing folds (aka reduces) that are efficient and makes one pass over data. This is a good library to expand your understanding of <code>Functor</code> and <code>Applicative</code>, and to understand efficiency concerns in a functional language.</p> <p>diagrams is a very well documented and powerful library for constructing 2D diagrams.</p>"},{"location":"resources/resources/#compiler","title":"Compiler","text":"<p>This is the guide to the Haskell compiler, GHC</p> <p>A guide on how to implement an interpreter (with sophisticated types)</p>"},{"location":"resources/stackoverflow/","title":"Stackoverflow","text":"<p>Many commonly asked Haskell questions have been given excellent answers on Stack Overflow:</p>"},{"location":"resources/stackoverflow/#profiling","title":"Profiling","text":"<p>Basics (note: quite old)</p>"},{"location":"resources/stackoverflow/#performance","title":"Performance","text":"<p>Haskell speed vs C</p> <p>Why is Haskell fast?</p>"},{"location":"resources/stackoverflow/#weak-head-normal-form","title":"Weak head normal form","text":"<p>What is it?</p> <p>Strictness annotations</p>"},{"location":"resources/stackoverflow/#haskells-type-system","title":"Haskell's type system","text":"<p>The tradeoffs of Haskell's type system</p>"},{"location":"resources/stackoverflow/#recursion","title":"Recursion","text":"<p>foldr vs foldl'</p>"},{"location":"resources/stackoverflow/#memoization","title":"Memoization","text":"<p>Pure memoization</p>"},{"location":"thinkingfunctionally/hof/","title":"Thinking functionally","text":"<p>Functions in Haskell are first class values, meaning they can be passed around like any other data (such are text or numbers), and also bound to names in the same way:</p> repl example<pre><code>&gt; notEven = (\\x -&gt; not (even x))\n&gt; notEven 3\nTrue\n&gt; notEven 4\nFalse\n&gt; test notEvenFunc = all (==False) [notEvenFunc (2*n) | n &lt;- [1..10]] -- (1)!\n&gt; test notEven\n\n-- a more concise definition\n&gt; equivalentNotEven = not . even -- (2)!\n&gt; equivalentNotEven 3\nTrue\n&gt; equivalentNotEven 4\nFalse\n&gt; test equivalentNotEven\nTrue\n\n-- even more direct!\n&gt; test (not . even) -- (3)!\nTrue\n</code></pre> <ol> <li> <p>Takes a function of type <code>Int -&gt; Bool</code> and tests if it returns <code>False</code> for <code>10</code> even numbers.</p> </li> <li> <p>See this section</p> </li> <li> <p>It's not even necessary to assign a variable name to the input function at all: just pass in <code>not . even</code> as an argument.</p> </li> </ol> <p>Functions can also return functions:</p> repl example<pre><code>&gt; mkNotEven isEvenFunc = \\n -&gt; not (isEvenFunc n)\n&gt; (mkNotEven even) 3 -- (1)!\nTrue\n\n-- equivalently\n&gt; mkNotEven2 isEvenFunc = not . isEvenFunc\n&gt; (mkNotEven2 even) 3\nTrue\n</code></pre> <ol> <li>The result of <code>mkNotEven</code>, when applied to <code>even</code>, is a function to tell if a number is odd. </li> </ol>  <p>Note</p> <p>A common use case for functions returning functions is currying. Relatedly, there are functions <code>curry</code> and <code>uncurry</code>:</p> repl example<pre><code>&gt; conjunction x y = x &amp;&amp; y\n&gt; :t conjunction\nconjunction :: Bool -&gt; Bool -&gt; Bool\n&gt; conjunction True False\nFalse\n\n(uncurry conjunction) :: (Bool, Bool) -&gt; Bool\n&gt; (uncurry conjunction) (True, False)\nFalse\n\n&gt; conjunction2 (x, y) = x &amp;&amp; y\n&gt; :t conjunction2\nconjunction2 :: (Bool, Bool) -&gt; Bool\n&gt; conjunction2 (True, False)\nFalse\n&gt; :t (curry conjunction2)\n(curry conjunction2) :: Bool -&gt; Bool -&gt; Bool\n&gt; (curry conjunction2) True False\nFalse\n</code></pre>"},{"location":"thinkingfunctionally/hof/#composition","title":"Composition","text":"<p><code>.</code> chains together (or composes) functions:</p> repl example<pre><code>import qualified Data.Text as T\n:set -XOverloadedStrings\n\n&gt; :t (=='a') -- (1)!\n(=='a') :: Char -&gt; Bool\n&gt; (=='a') 'b' \nFalse\n\n&gt; :t T.head \nT.head :: Text -&gt; Char\n&gt; T.head \"hello\"\n'h'\n\n&gt; :t ( (=='a') . T.head)\n( (=='a') . T.head) :: Text -&gt; Bool\n&gt; ( (=='a') . T.head) \"hello\"\nFalse\n</code></pre> <ol> <li> <p><code>(=='a')</code> is the function which takes a <code>Char</code> and returns <code>True</code> if it is <code>a</code> otherwise <code>False</code>.</p> </li> <li> <p>Here also, the repl gives a more general type. What is shown is more specific, but still true.</p> </li> </ol> <p>The composition operator <code>.</code> is not a special syntax; it is a function, typically written in infix position like <code>+</code> or <code>*</code>, with the following type:</p> <pre><code>(.) :: (Char -&gt; Bool) -&gt; (Text -&gt; Char) -&gt; (Text -&gt; Bool)\n</code></pre> <p>Or in its general form:</p> <pre><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)\n</code></pre>"},{"location":"thinkingfunctionally/hof/#pointfree-code","title":"Pointfree code","text":"<p>Instead of writing <code>func x = not (even x)</code>, one can write <code>func = not . even</code>, which avoids having to name a variable <code>x</code> at all. </p> pointful stylepointfree style   <pre><code>import Graphics.Gloss.Data.Picture -- (1)!\npicture :: Picture\npicture = \n    rotate 90\n    $ translate 20 20\n    $ scale 30 30\n    circle 2\n</code></pre> <ol> <li>Requires the <code>gloss</code> package.</li> </ol>   <pre><code>import Graphics.Gloss.Data.Picture -- (1)!\npicture :: Picture\npicture = transform (circle 2) where \n    transform =\n        rotate 90\n        . translate 20 20\n        . scale 30 30\n</code></pre> <ol> <li>Requires the <code>gloss</code> package.</li> </ol>    <p>Using <code>flip</code>:</p> pointful stylepointfree style (with <code>flip</code>)   <pre><code>&gt; threeMinusN n = subtract n 3 \n&gt; threeMinusN 6\n-3\n\n-- or (re the above example)\n&gt; translateXBy n = translate n 0\n</code></pre>   <pre><code>&gt; threeMinusN = flip subtract 3\n&gt; threeMinusN 6\n-3\n\n-- or (re the above example)\n&gt; translateXBy = flip translate 0\n</code></pre>"},{"location":"thinkingfunctionally/hof/#map-fold-scan-and-zip","title":"Map, fold, scan and zip","text":""},{"location":"thinkingfunctionally/hof/#map","title":"Map","text":"<pre><code>map :: (a -&gt; b) -&gt; ([a] -&gt; [b])  -- (1)!\n</code></pre> <ol> <li>Your repl will display: (a -&gt; b) -&gt; [a] -&gt; [b], leaving the brackets implicit. </li> </ol> <p><code>map f ls</code> gives the same result as the Python list comprehension <code>[f(x) for x in ls]</code>. That is, it applies a function <code>f</code> to each element of a list.</p>  Info <p>In Haskell, one can also write a list comprehension, as: <code>[f x | x &lt;- list]</code>.</p>  <p>Note that <code>map</code>'s type ranges over all types <code>a</code> and <code>b</code>. This means that it can change the type of the values of the list.</p> <pre><code>&gt; map (&gt; 5) [1..10]\n[False,False,False,False,False,True,True,True,True,True]\n\n&gt; data Piece = Bishop | Knight deriving Show\n&gt; map show [Bishop, Knight, Knight]\n[\"Bishop\",\"Knight\",\"Knight\"] \n</code></pre>"},{"location":"thinkingfunctionally/hof/#folds","title":"Folds","text":"repl example<pre><code>&gt; foldr (+) 0 [1..10]\n55\n&gt; :t foldr\nfoldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b -- (1)!\n</code></pre> <ol> <li>Actually, the repl will give a more general type: <code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</code>. This generalizes <code>foldr</code> from lists to any kind of \"container\" type that is an instance of the <code>Foldable</code> typeclass. </li> </ol> <p>The first argument (here <code>(+)</code>) is a function of type <code>a -&gt; (b -&gt; b)</code> (or here specifically: <code>Int -&gt; (Int -&gt; Int)</code>) to combine the list elements. The second argument (here <code>0</code>) is an initial value, to be returned if the input list is the empty list <code>[]</code>. The third argument is the input list to be folded, here <code>[1,2,3,4,5,6,7,8,9,10]</code>.</p> <p>This is by no means restricted to numerical code:</p> <pre><code>data Piece = Bishop | Knight | Rook deriving Show\nfindBestPiece = foldr best Bishop [Bishop, Knight, Rook, Bishop] \n\n    where\n\n        best piece1 piece2\n            | value piece1 &gt;= value piece2 = piece1\n            | otherwise = piece2\n\n        value piece = case piece of\n            Bishop -&gt; 3\n            Knight -&gt; 3\n            Rook -&gt; 5\n</code></pre>  <p>Tip</p> <p>In Haskell, it is often preferable to rely on functions like <code>foldr</code> instead of writing explicit recursion yourself.</p> Explicit recursionUsing higher-order function   <pre><code>sumList (x:xs) = x + sumList xs\nsumList [x] = x\n</code></pre>   <pre><code>sumList = foldr 0 (+) -- (1)!\n</code></pre> <ol> <li>In fact, Haskell already provides this function, and calls it <code>sum</code>.</li> </ol>    <p>This is for two reasons:</p> <ol> <li>It avoids buggy code. For example, <code>sumList</code> fails on the empty list <code>[]</code>.</li> <li>It is easier to understand. Explicit recursion can create \"goto\" like control flow.</li> </ol> <p>Many programs can be expressed as folds (or unfolds!) over lists or other data structures, and Haskell has a range of intermediate and advanced libraries to write time/space efficient one-pass folds over complex data.</p>"},{"location":"thinkingfunctionally/hof/#unfolds","title":"Unfolds","text":"repl example<pre><code>import Data.List\n&gt; unfoldr (\\x -&gt; if x &gt; 20 then Nothing else Just (even x, x + 3)) 0\n[True,False,True,False,True,False,True]\n</code></pre>  <p>Tip</p> <p>Use laziness to unfold an infinite structure and then fold it back.</p> repl example<pre><code>&gt; let evens = unfoldr (\\x -&gt; Just (x + 2, x + 2)) 0 -- (1)!\n\n&gt; foldr (+) 0 (take 10 evens)\n110\n\n&gt; any (&gt;10) evens -- (2)!\nTrue\n</code></pre> <ol> <li>An infinite list of even numbers.</li> <li><code>any</code> is really just a fold, and can be defined in terms of <code>foldr</code>.</li> </ol>"},{"location":"thinkingfunctionally/hof/#scans","title":"Scans","text":"repl example<pre><code>&gt; scanl (+) 0 [1,1,1,1]\n[0,1,2,3,4]\n</code></pre>  <p>Tip</p> <p>This corresponds to code that you would write with an accumulator in a non-functional language.</p>"},{"location":"thinkingfunctionally/hof/#illustrative-examples","title":"Illustrative examples","text":"<p>Under </p>"},{"location":"thinkingfunctionally/immutability/","title":"Immutability","text":"<p>When you write a definition in your code, like:</p> <pre><code>flag = True -- (1)!\n</code></pre> <ol> <li><code>flag</code> isn't a keyword, it's just a normal variable name.</li> </ol> <p>or </p> <pre><code>swap (a, b) = (b, a)\n</code></pre> <p>you cannot later write in the same codebase:</p> <pre><code>flag = False\n</code></pre> <p>or </p> <pre><code>swap (a, b) = (a, b)\n</code></pre> <p>This is because all Haskell values (including functions) are immutable. To write <code>a = b</code> is simply to state that <code>a</code> is a name for <code>b</code>, and that wherever you see <code>a</code> in the code, it can be replaced by <code>b</code>.</p> <p>For example, given the definition <code>swap (a, b) = (b, a)</code>, whenever you see <code>swap (a, b)</code> in your code, it can be replaced by <code>(b, a)</code>.</p>"},{"location":"thinkingfunctionally/immutability/#loops-and-mutation","title":"Loops and mutation","text":"<p>In Python you could write:</p> <pre><code>x = 0\nfor i in range(10):\n    x += i\n</code></pre> <p>This imperative approach isn't usually the natural one in a functional language. </p>  <p>Note</p> <p>There are fairly simple ways to write code like this, e.g.:</p> <pre><code>import Control.Monad (forM)\nimport Control.Monad.State (execState, modify)\n\nloop = flip execState 0 $ forM [0..9] $ \\i -&gt; -- (1)!\n    modify (+i)\n</code></pre> <ol> <li>Here, <code>forM</code> and <code>modify</code> are just regular functions, not built-in control-flow operators.  </li> </ol> <p>However, there's often a simpler solution that avoids thinking about loops and state altogether.</p>  <p>Instead, you could write:</p> <pre><code>x = sum [0..9]\n</code></pre> <p>See this section for how this kind of approach scales to more complex situations.</p>"},{"location":"thinkingfunctionally/purity/","title":"Purity","text":"<p>Given a function, for example a function <code>f</code> of type <code>Int -&gt; Bool</code>, the effect of calling the function on an <code>Int</code> must be nothing other than returning a <code>Bool</code>.</p> <p>For example, <code>f</code> cannot read a file, write to command line, or start a thread, as a side effect of being called.</p> <p>Of course, it is possible to do all these things, but requires a change to the type:</p> <pre><code>add1AndPrint :: Int -&gt; IO Bool\nadd1AndPrint x = (print x) &gt;&gt; (return (x &gt; 1)) -- (1)!\n</code></pre> <ol> <li>Fewer brackets are fine (<code>add1AndPrint x = print x &gt;&gt; return (x &gt; 1)</code>), and are here just for clarity.</li> </ol> <p>This applies not just to functions, but all values:</p> repl example<pre><code>&gt; let boolean = print \"hello\" &gt;&gt; return True\n&gt; :t boolean\nboolean :: IO Bool -- (1)!\n&gt; boolean\n\"hello\"\nTrue\n</code></pre> <ol> <li><code>x</code> cannot have type <code>Bool</code> - it has to mark in its type the fact that it involves the operation of printing.</li> </ol>"},{"location":"thinkingfunctionally/purity/#the-benefit-of-purity","title":"The benefit of purity","text":"<p>Because of purity, a function will give the same answer no matter where or when it is called, as long as the input is the same. This makes parallelism easy, often almost trivial:</p> Run tests sequentiallyRun tests in parallel   <pre><code>main :: IO ()\nmain = hspec $ do\n    ... tests ...\n</code></pre>   <pre><code>main :: IO ()\nmain = hspec $ parallel $ do\n    ... tests ...\n</code></pre>    <p>Purity also lends itself to modular code, and easy refactoring. Consider:</p> <pre><code>graphicalUserInterface = runWith complexFunction\n    where \n        complexFunction :: UserInput -&gt; Picture\n        complexFunction = ...\n\n        runWith = ... -- e.g., a handler function\n</code></pre> <p>Suppose we want to replace <code>complexFunction</code> with <code>simpleFunction</code>, which also has the type  <code>UserInput -&gt; Picture</code>.</p> <p>Because Haskell is pure (but see caveats) and so <code>complexFunction</code> is not creating/mutating global variables, or opening or closing files, we can be confident that there will be no unexpected implications of making the change, such as a subtle error with changed variable assignment, when <code>runWith</code> takes <code>complexFunction</code> as input. </p>"},{"location":"thinkingfunctionally/purity/#equational-reasoning","title":"Equational reasoning","text":"<p>Because of purity, you may always replace a function call in Haskell with its resulting value. For instance, if the value of <code>positionOfWhiteKing chessboard</code> is <code>\"a4\"</code>, then this</p> <pre><code>exampleProgram = someFunction (positionOfWhiteKing chessboard)\n</code></pre> <p>is equivalent to</p> <pre><code>exampleProgram = someFunction \"a4\"\n</code></pre>  <p>Tip</p> <p>Use this fact to understand complex programs, by substituting complex expressions for their values:</p> <pre><code>data Piece = Bishop | Rook | King\ntake 2 [Bishop, Rook, Bishop]\n</code></pre> <p>To work out what this does, we consult the definition of <code>take</code> (shown here with some aesthetic simplifications for clarity):</p> <pre><code>take 0 ls = []\ntake _ [] = []\ntake n (firstElem : rest) = firstElem : take (n-1) rest\n</code></pre> <p>Following this definition, we replace <code>take 2 [1,2,3]</code> (or more explicitly, <code>#1hs take 2 (1 : [2,3])</code>) with the pattern that it matches:</p> <pre><code>    take 2 (Bishop : [Rook, Bishop]) \n    = Bishop : take (2-1) [Rook, Bishop] \n    = Bishop : take 1 (Rook : [Bishop])\n</code></pre> <p>We can continue in this vein, repeatedly consulting the definition of <code>take</code>:</p> <pre><code>    = Bishop : take 1 (Rook : [Bishop])\n    = Bishop : (Rook : take (1 - 1) [Bishop])\n    = Bishop : (Rook : take 0 [Bishop]) \n    = Bishop : (Rook : [])\n    = [Bishop, Rook]\n</code></pre> <p>This technique is always applicable, no mater how complex the program.</p>"},{"location":"thinkingfunctionally/purity/#totality","title":"Totality","text":"<p>A function is total if it returns a result for any possible input. For example, <code>head</code> is not total:</p> repl example<pre><code>&gt; head [1,2]\n1\n&gt; head []\n*** Exception: Prelude.head: empty list\n</code></pre> <p>In Haskell, non-total (aka partial) functions are permitted, although they are discouraged. Functions may be partial by throwing an runtime error on some inputs (like <code>head</code>), or by running indefinitely, (like <code>last [1..]</code>). Haskell will generally warn you about the first kind, but not the second, since it is harder to detect.</p>"},{"location":"thinkingfunctionally/purity/#caveats","title":"Caveats","text":"<p>Haskell allows a backdoor, mainly useful for debugging. </p> <p>This is the ability for functions to throw an \"unsafe\" error:</p> repl example<pre><code>let x = undefined\n&gt; :t x\nx :: a\n&gt; x\n\"*** Exception: Prelude.undefined...\"\n</code></pre> <p><code>undefined</code> has the type <code>forall a. a</code>, so it can appear anywhere in a program and assume the correct type (see here for more details on how universal quantification works). </p> <p>As such, it is useful as a \"to do\" marker (see type driven development).</p>"},{"location":"thinkingfunctionally/typechecking/","title":"Type Checking","text":"<p>A Haskell program won't compile unless the types are consistent, and no coercion of types will take place automatically:</p> <pre><code>intToBool :: Int -&gt; Bool\nintToBool x = x &gt; 5\n\n-- this line won't type check!\nbadInput = intToBool True\n</code></pre> <p><code>badInput</code> won't compile, because it fails to typecheck: it tries to apply <code>intToBool</code> to a <code>Bool</code>, but <code>intToBool</code> takes an <code>Int</code> as input.</p> <p>The compiler will provide an error which tells you this:</p>"},{"location":"thinkingfunctionally/typechecking/#why-this-is-useful","title":"Why this is useful","text":"<p>In conjunction with Haskell's ability to create custom types, static typing allows you to enforce conceptual distinctions, which can vastly increase code safety and understanding:</p> <pre><code>data ChessSquare = Square Int Int\ndata Color = Black | White deriving Show\n\nsquareColor :: ChessSquare -&gt; Color\nsquareColor (Square i j) \n    | even (i+j) = White\n    | otherwise = Black\n\ncorrect =  squareColor (Square 2 4)\n\n-- this line won't type check, and your program won't compile!\nincorrect = squareColor (2,4)\n</code></pre> <p><code>incorrect</code> won't compile, because it fails to typecheck: it tries to apply <code>squareColor</code> to a tuple <code>(Int, Int)</code>, but <code>squareColor</code> takes a <code>ChessSquare</code> as input.</p> <p>Even though a <code>ChessSquare</code> is a pair of integers \"under the hood\", it represents a square on a chess board, and your code (such as <code>squareColor</code>) will respect this distinction.</p>"},{"location":"thinkingfunctionally/typechecking/#how-to-debug-a-type-error","title":"How to debug a type error","text":"<p>The most general strategy for debugging a type error (aside from carefully reading the error message) is to replace expressions in your program with <code>undefined</code>.</p> <p>For example</p> <pre><code>example = fst (intToBool 4)\n</code></pre> <p>will fail to typecheck. One could first replace <code>4</code> with <code>undefined</code>:</p> <pre><code>example = fst (intToBool undefined)\n</code></pre> <p>This will still fail to typecheck, so the problem is not the argument of <code>intToBool</code>. </p> <p>As a next step, replace a larger expression:</p> <pre><code>example = fst (undefined)\n</code></pre> <p>This will typecheck, so you know that the problem is the output of <code>intToBool</code>. (More specifically, <code>fst</code> expects a tuple, but gets a <code>Bool</code>.)</p> <p>Once you have removed the error, you can ask the compiler for the type of the expression you replaced with <code>undefined</code>. See the next section for details.</p>"},{"location":"thinkingfunctionally/typeinference/","title":"Type Inference","text":"<p>Haskell is able to infer the type of all expressions1.</p> <p>A simple example you can run in the repl:</p> <pre><code>&gt; exampleValue = True\n&gt; :t exampleValue\nexampleValue :: Bool\n</code></pre> <p>A more complex example:</p> <pre><code>data ChessPiece = Piece PieceType Color\ndata Color = Black | White\ndata PieceType = Bishop | Rook\n\nisPieceWhite = \\case\n    Piece _ White -&gt; True\n    _ -&gt; False\n</code></pre> <p>Haskell's inference about the type of the whole program is shown here, via the Haskell Language Server, which offers to autocomplete it for you. (If you don't have the Haskell Language Server, do the same in the repl with <code>:t isPieceWhite</code>)</p>  <p>One can also mouse over any expression in the program:</p>  <p>(If you don't have the Haskell Language Server, do the same by replacing the expression in question with an <code>_</code>)</p>"},{"location":"thinkingfunctionally/typeinference/#type-driven-development","title":"Type-driven development","text":"<p>The expressive types and automatic inference let you develop a complicated program top-down, by starting with the type signature of the whole program and filling in gaps incrementally. For example:</p> <pre><code>main :: IO ()\nmain = runInputT defaultSettings $ flip evalStateT initBoard $ forever $ do\n    line &lt;- lift requestLine \n    let instruction = parseInput line\n    board &lt;- get\n    let result = evaluate instruction board\n    case result of\n        Right (BoardUpdate update) -&gt; modify update\n        Right DisplayBoard -&gt; lift $ outputStr $ T.unpack $ display board\n        Left err -&gt; lift $ outputStr err\n\n    where \n\n        evaluate = undefined\n        display = undefined\n</code></pre> <p>Here, <code>undefined</code> stands for a piece of code that is yet to be written. The compiler will typecheck this program, even with the <code>undefined</code>s left in, so you can be sure that it is consistent, before proceeding to fill in the gaps.</p> <p>More importantly, it will infer the type of each <code>undefined</code>, like so:</p>  <p>Especially for more complex programs, the compiler's understanding of the types of unwritten parts of your program can be invaluable.</p>"},{"location":"thinkingfunctionally/typeinference/#type-based-refactoring","title":"Type based refactoring","text":"<p>Because types are expressive in Haskell, and type errors are static, refactoring a codebase can be performed with the help of the compiler:</p> <pre><code>type Position = (Double, Double)\n</code></pre> <p>Here, if we changed the definition of <code>Position</code> to <code>type Position = (Double, Double, Double)</code>, we would be shown a list of compiler errors (in the <code>Problems</code> tab in VSCode's terminal), which we could then fix one-by-one until the code compiles again.</p>   <ol> <li> <p>There are exceptions, but they involve advanced techniques.\u00a0\u21a9</p> </li> </ol>"},{"location":"typeclasses/overview/","title":"Typeclasses","text":"<p>Typeclasses allow the user to add constraints to universally quantified types:</p> without explicit quantifier (standard)with explicit quantifier   <pre><code>notEqual :: Eq a =&gt; (a, a) -&gt; Bool \nnotEqual (x,y) = not (x == y)\n</code></pre>   <pre><code>notEqual :: forall a. Eq a =&gt; (a, a) -&gt; Bool -- (1)!\nnotEqual (x,y) = not (x == y)\n</code></pre> <ol> <li>Requires the <code>ExplicitForall</code> extension.</li> </ol>    <p>The type of <code>notEqual</code> states: for any type <code>a</code> such that <code>a</code> is an instance of the <code>Eq</code> typeclass, given a pair of <code>a</code>s, this will return a <code>Bool</code>.</p>  <p>Note</p> <p><code>Eq a</code> is not a type, but rather a different kind of entity, called a constraint.</p> <p><code>Eq</code> is referred to as a typeclass.</p>"},{"location":"typeclasses/overview/#basics","title":"Basics","text":"<p>Typeclasses, such as <code>Eq</code>, are defined as follows:</p> <pre><code>class  Eq a  where\n    (==) :: a -&gt; a -&gt; Bool --(1)!\n</code></pre> <ol> <li>The actual definition has a second method, <code>(/=)</code>, omitted here for clarity.</li> </ol> <p>Here, <code>(==)</code> is a method of the <code>Eq</code> typeclass.</p> <p>To make a type be an instance of a type class, one writes a definition of the method(s) for the type in question:</p> <pre><code>instance Eq Bool where\n    True == True = True\n    False == False = True\n    _ == _ = False\n</code></pre>"},{"location":"typeclasses/overview/#automatically-deriving-instances","title":"Automatically deriving instances","text":"repl example<pre><code>&gt; data Piece = Bishop | Knight deriving (Eq, Ord, Show)\n\n&gt; Bishop == Knight\nFalse\n&gt; show Bishop\n\"Bishop\"\n&gt; import Data.List\n&gt; sort [Knight, Bishop]\n[Bishop,Knight]\n</code></pre>"},{"location":"typeclasses/overview/#different-instances-for-the-same-type","title":"Different instances for the same type","text":"<p>A single type can have at most one instance for a typeclass.</p> <p>However, two types which are isomorphic can have different instances:</p> <pre><code>import qualified Data.Text as T\n\ndata InterspersedText = MkI {getText :: T.Text} deriving Show -- (1)!\n\ninstance Semigroup InterspersedText where  --(2)!\n    (MkI t1) &lt;&gt; (MkI t2) = MkI \n        $ T.concat \n        $ fmap (\\(c1, c2) -&gt; T.pack [c1,c2]) \n        $ T.zip t1 t2\n</code></pre> <ol> <li> <p><code>InterspersedText</code> and <code>Text</code> contain the same data in the sense that <code>MkI :: Text -&gt; InterspersedText</code> and <code>getText :: InterspersedText -&gt; Text</code> map back and forth losslessly.</p> </li> <li> <p>This isn't a sensible instance in practice and is only exemplary, not least because it breaks the associativity law for <code>Semigroup</code></p> </li> </ol> <p><code>InterspersedText</code> and <code>Text</code> contain the same information, but have different <code>Semigroup</code> instances. </p> repl example<pre><code>&gt; (MkI \"foo\") &lt;&gt; (MkI \"bar\")\nMkI \"fboaor\"\n\n&gt; \"foo\" &lt;&gt; \"bar\"\n\"foobar\"\n</code></pre> <p>For a practical example, see the Sum and Product types. The type <code>Sum Int</code> is isomorphic to <code>Int</code>, but they have different <code>Monoid</code> instances.</p> repl example<pre><code>-- the (Sum Int) Monoid\n&gt; Sum 4 -- (1)!\nSum {getSum = 4}\n&gt; :t Sum 4\nSum 4 :: Num a =&gt; Sum a\n&gt; Sum 4 &lt;&gt; Sum 5\nSum {getSum = 9}\n\n-- the (Product Int) Monoid\n&gt; Product 4\nProduct {getProduct = 4}\n&gt; :t Product 4\nProduct 4 :: Num a =&gt; Product a\n&gt; Product 4 &lt;&gt; Product 5\nProduct {getProduct = 20}\n</code></pre> <ol> <li><code>Sum</code> is both the function which maps a number to a value of the <code>Sum</code> type, and the name of the type. See this page on punning.</li> </ol>  Note <p>One other useful example is the logarithm type <code>Log</code>, from the <code>log-domain</code> package.</p> <pre><code>&gt; import Numeric.Log\n&gt; :i Log -- (1)!\nnewtype Log a = Exp {ln :: a} -- (2)!\n...\ninstance RealFloat a =&gt; Num (Log a) --(3)!\n\n&gt; Exp 0 \n1.0 -- (4)!\n&gt; Exp 0 * Exp 0 -- (5)!\n2.0\n</code></pre> <ol> <li><code>:i</code> prompts the repl to give info about an expression.</li> <li>The definition of the <code>Log</code> type.</li> <li>Read this as saying: \"if the type <code>a</code> is an instance of <code>RealFloat</code>, then the type <code>Log a</code> is an instance of <code>Num</code>. See this section for more.</li> <li><code>Exp 0</code> represents the real number <code>1</code>, but under the hood, stores it in log-space as <code>0</code>.</li> <li>The definition of <code>*</code> (which is part of the instance for <code>Num</code>) adds the log-space numbers, rather than multiplying the real-space numbers. </li> </ol>"},{"location":"typeclasses/overview/#constraint-implication-classes","title":"Constraint implication (classes)","text":"<p>One typeclass may depend on another:</p> <pre><code>class Semigroup a where\n    (&lt;&gt;) :: a -&gt; a -&gt; a\n\nclass Semigroup a =&gt; Monoid a where\n    mempty :: a\n</code></pre> <p>What this means is that any instance of Monoid must first be an instance of Semigroup (as well as implementing the <code>Monoid</code> method <code>mempty</code>).</p> <p>This means that if you encounter a type that is an instance of <code>Monoid</code>, then it will be an instance of <code>Semigroup</code> and so you can use the method <code>&lt;&gt;</code>. For this reason, this is often called inheritance , although the relationship to inheritance in other languages is not direct.</p>"},{"location":"typeclasses/overview/#constraint-implication-instances","title":"Constraint implication (instances)","text":"<pre><code>instance Eq a =&gt; Eq [a] where\n    ls1 == ls2 = ...\n</code></pre> <p>Read this as saying: for any type <code>a</code>, if <code>a</code> is an instance of <code>Eq</code>, then <code>[a]</code> is also an instance of <code>Eq</code>. </p> <p>Similarly:</p> <pre><code>instance Num a =&gt; Monoid (Sum a)\n</code></pre> <p>This states that if <code>a</code> is an instance of <code>Num</code> (as are e.g. <code>Int</code> and <code>Double</code>) then <code>Sum a</code> (or concretely, <code>Sum Int</code> or <code>Sum Int</code>) are instances of <code>Monoid</code>.</p> <p>This allows Haskell's type checker to make potentially quite complex deductions. For example:</p> <pre><code>compareLists :: Ord a =&gt; ([a], [a]) -&gt; Bool\ncompareLists (x, y) = x == y\n</code></pre> <p>Haskell knows that <code>==</code> can be called on <code>x</code> and <code>y</code>. How?</p> <ol> <li>It knows that <code>x</code> and <code>y</code> both have type <code>[a]</code></li> <li>It knows that <code>a</code> is an instance of <code>Ord</code> (from the type signature)</li> <li>It knows that <code>Ord a</code> implies <code>Eq a</code></li> <li>It knows that <code>Eq a</code> implies <code>Eq [a]</code></li> </ol>  <p>Note</p> <p>Libraries like lens use the ability of the type checker to make these deductions in sophisticated ways.</p>"},{"location":"typeclasses/overview/#typeclass-error-messages","title":"Typeclass error messages","text":"repl example<pre><code>&gt; import Data.List\n\n&gt; data Piece = Bishop | Knight deriving Eq\n\n&gt; sort [Knight, Bishop]\n\n\"No instance for (Ord Piece) arising from a use of \u2018sort\u2019...\"\n</code></pre> <p>The error is raised because <code>sort</code> has type <code>sort :: Ord a =&gt; [a] -&gt; [a]</code>, which means that it expects as input, a list of values of a type which is an instance of the <code>Ord</code> class.</p>"},{"location":"typeclasses/overview/#using-typeclasses","title":"Using typeclasses","text":"<p>Warning</p> <p>It is recommended that you avoid creating your own type classes unless it is entirely necessary. This is because:</p> <ol> <li>There is usually a solution to a problem which doesn't require typeclasses.</li> <li>It is easy to create a typeclass that is badly designed.</li> </ol> <p>Instead, rely on existing type classes from libraries. </p>"},{"location":"typeclasses/overview/#constraints-float-up","title":"Constraints float up","text":"repl example<pre><code>5 :: Num a =&gt; a\n\n&gt; :t 5\n5 :: Num a =&gt; a\n&gt; :t [5, 4]\n[5, 4] :: Num a =&gt; [a] -- (1)!\n\n&gt; :t (True, 4)\n(True, 4) :: Num b =&gt; (Bool, b)\n\n-- with custom type\n&gt; data Square a = Empty | Piece a\n&gt; :t Piece 4\nPiece 4 :: Num a =&gt; Square a\n</code></pre> <ol> <li>Not <code>[forall a . Num a =&gt; a]</code> which is a very different type, beyond the scope of this guide.</li> </ol> <p>Similarly, if a function which requires a constraint is used as part of a larger program, that constraint floats to the top:</p> <pre><code>complexFunction :: Eq a =&gt; a -&gt; ...\ncomplexFunction x = let y = notEqual (x, x) in ...\n</code></pre> <p>Because <code>notEqual</code> is called on <code>(x, x)</code>, <code>x</code> must be of a type that is an instance of <code>Eq</code>. </p> <p>The compiler will reason in this way, even if you don't write down the type signature yourself.</p>  <p>Tip</p> <p>A common difficulty that you may encounter is that you don't know what instance of a typeclass is being invoked:</p> <pre><code>-- first example\n{-# LANGUAGE OverloadedStrings #-}\nimport Data.Text\nexample :: Text\nexample = \"hello\" `append` mempty \n</code></pre> <p>In this case, you know the type of <code>mempty</code>, which is <code>mempty :: forall a. Monoid a =&gt; a</code>. However, you do not know which instance of <code>Monoid</code> is being used when <code>mempty</code> is called. Mousing over <code>mempty</code> in VSCode will reveal that the instance is <code>Text</code>.</p> <p>You can then look up <code>Text</code> on Hackage and find the source, which gives the definition of <code>mempty</code> for <code>Text</code>.</p>"},{"location":"typeclasses/overview/#type-class-recursion","title":"Type class recursion","text":"<p>Type class instances may use the very method they are defining in the definition.</p> <pre><code>instance Eq (Int, Int) where\n    (x, y) == (x', y') = (x == x') &amp;&amp; (y == y')\n</code></pre>  <p>Note</p> <p>Here, <code>==</code> on the right hand side of the definition is the <code>Eq</code> method for <code>Int</code>, but on the right hand side, it is the method for <code>(Int, Int)</code>.</p>  repl example<pre><code>&gt; (4,3) == (4,3)\nTrue\n</code></pre>"},{"location":"typeclasses/overview/#type-classes-over-others-kinds","title":"Type classes over others kinds","text":"<p>In the typeclass <code>Eq</code>, types which are instances are normal types like <code>Int</code>, <code>Bool</code>, or <code>Either Int Bool</code>, i.e. types with kind <code>*</code>.</p>  Note <p>Accordingly, a type signature like </p> <pre><code>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool\n</code></pre> <p>can be more explicitly stated as:</p> <pre><code>(==) :: forall (a :: *). Eq a =&gt; a -&gt; a -&gt; Bool\n</code></pre>  <p>However, for many important typeclasses, the types which are instances have other kinds, like <code>* -&gt; *</code>. For instance:</p> <pre><code>class Functor (f :: * -&gt; *) where\n  fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>This means that <code>[]</code> or <code>Maybe</code> are candidates to be instances of <code>Functor</code>, but <code>Int</code>, <code>Bool</code>, (or even <code>[Int]</code>) are not.</p>"},{"location":"typeclasses/survey/","title":"Important typeclasses","text":""},{"location":"typeclasses/survey/#understanding-a-typeclass","title":"Understanding a typeclass","text":"<p>The best way to understand any given typeclass is to find its documentation online, inspect its methods, and look at some instances. This is usually easy with Google, or failing that, Hoogle.</p> <p>Here is an example, the <code>Semigroup</code> class:</p>  <p>To understand what methods the class requires for its instances, see \"minimal complete definition\" where <code>(&lt;&gt;)</code> is the only (required) method. See below for its type.</p>  <p>Note</p> <p>You will also see a comment about associativity, which is a property that instances should have. This property can't be automatically enforced, so is the responsibility of the writer of the instance.</p>  <p>The next step is to inspect some instances, which are also listed below, like:</p>"},{"location":"typeclasses/survey/#info","title":"<code>:info</code>","text":"<p>The Haskell repl will also provide useful information:</p> repl example<pre><code>&gt; :info Num\ntype Num :: * -&gt; Constraint\nclass Num a where\n  (+) :: a -&gt; a -&gt; a\n  (-) :: a -&gt; a -&gt; a\n  (*) :: a -&gt; a -&gt; a\n  negate :: a -&gt; a\n  abs :: a -&gt; a\n  signum :: a -&gt; a\n  fromInteger :: Integer -&gt; a\n  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}\n\ninstance Num Word -- Defined in \u2018GHC.Num\u2019\ninstance Num Integer -- Defined in \u2018GHC.Num\u2019\ninstance Num Int -- Defined in \u2018GHC.Num\u2019\ninstance Num Float -- Defined in \u2018GHC.Float\u2019\ninstance Num Double -- Defined in \u2018GHC.Float\u2019\n</code></pre>"},{"location":"typeclasses/survey/#show","title":"Show","text":"<p>A class for converting a type into a <code>String</code>, which can be displayed. <code>String</code> is a legacy type, but <code>Show</code> is widely used, and can be derived by Haskell:</p> repl example<pre><code>&gt; data Piece = Bishop | Knight deriving Show\n&gt; show Bishop\n\"Bishop\"\n</code></pre> <p>Most instances that should exist do exist. For example:</p> <ul> <li><code>instance Show Int</code></li> <li><code>instance Show Bool</code></li> <li><code>instance Show a =&gt; Show [a]</code></li> <li><code>instance Show a =&gt; Show (Maybe a)</code></li> </ul>  <p>Gotcha</p> repl example<pre><code>&gt; show (+)\n\"No instance for (Show (Integer -&gt; Integer -&gt; Integer))...\"\n</code></pre> <p>Haskell won't show arbitrary functions, because they don't have a <code>Show</code> instance. This makes sense, since it is impossible to show all the (infinite) input-output pairs of a function.</p>"},{"location":"typeclasses/survey/#eq","title":"Eq","text":"<p>Types which support a notion of equality.</p>"},{"location":"typeclasses/survey/#ord","title":"Ord","text":"<p>Types which support a notion of comparison.</p>"},{"location":"typeclasses/survey/#num","title":"Num","text":"<p>Types which support a notion of addition, multiplication and negation. Some laws, like commutativity of addition, are expected to hold. </p>"},{"location":"typeclasses/survey/#semigroup","title":"Semigroup","text":"<p>Provides a method to combine two values: <code>(&lt;&gt;) :: a -&gt; a -&gt; a</code></p> <p>Any instance should define <code>&lt;&gt;</code> such that it is associative (i.e. <code>a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c</code>)</p>"},{"location":"typeclasses/survey/#instance-semigroup-text","title":"<code>instance Semigroup Text</code>","text":"repl example<pre><code>&gt; :set -XOverloadedStrings -- (1)!\n&gt; import Data.Text\n&gt; text = \"hello\"\n&gt; text2 = \"world\"\n&gt; text &lt;&gt; text2\n\"helloworld\"\n</code></pre> <ol> <li>See here for explanation of why this is needed.</li> </ol>"},{"location":"typeclasses/survey/#monoid","title":"Monoid","text":"Info <p>For historical reasons (<code>Monoid</code> predates <code>Semigroup</code>), <code>Monoid</code> has a method <code>mappend</code> which is redundant given the inheritance of <code>&lt;&gt;</code> from <code>Semigroup</code>.</p>  <p>The <code>Monoid</code> constraint implies the <code>Semigroup</code> constraint.</p> <pre><code>class Semigroup a =&gt; Monoid a where\n  mempty :: a\n</code></pre> <p><code>mempty</code> (short for: monoid empty) is a value of type <code>a</code>.</p> <p>Examples:</p> repl example<pre><code>&gt; mempty :: Any\n\nAny {getAny = False}\n&gt; mempty :: All\n\nAll {getAll = True}\n\n&gt; mempty :: Product Int -- (1)!\nProduct {getProduct = 1}\n\n&gt; mempty :: Sum Int\nSum {getSum = 0}\n\n&gt; mempty :: [Int]\n[]\n&gt; mempty :: [Bool]\n[]\n&gt; mempty :: [a]\n[]\n\n&gt; import Data.Text\n&gt; mempty :: Text\n\"\"\n\n-- if X has a Monoid instance, so does (Y -&gt; X) for any Y.\n&gt; (mempty :: Int -&gt; Text) 4\n\"\"\n&gt; (mempty :: Int -&gt; Text) 6\n\"\"\n</code></pre> <ol> <li><code>Product X</code> has a <code>Monoid</code> instance if <code>X</code> has a <code>Num</code> instance. </li> </ol>"},{"location":"typeclasses/survey/#functor","title":"Functor","text":"with explicit kind signaturewithout explicit kind signature   <pre><code>class Functor (f :: * -&gt; *) where -- (1)!\n    fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <ol> <li>The kind signature <code>f :: * -&gt; *</code> requires the GHC2021 standard extensions.</li> </ol>   <pre><code>class Functor f where\n    fmap :: (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre>     <p>Hint</p> <p>Types which are instances of <code>Functor</code> must have kind <code>* -&gt; *</code>.</p> <p>So <code>Int</code> or <code>Bool</code> or <code>Either Int Bool</code> or <code>[Int]</code> cannot be instances of <code>Functor</code>, but <code>Either Int</code>, or <code>[]</code> can. (See section on partial application of types.)</p>"},{"location":"typeclasses/survey/#list","title":"List","text":"<p>The definition of <code>fmap</code> for <code>[]</code> is just map</p> repl example<pre><code>&gt; ls = [1 :: Int, 2, 3]\n&gt; :t ls \nls :: [Int]\n&gt; fmap even ls\n[False,True,False]\n&gt; :t fmap even ls\nfmap even ls :: [Bool]\n</code></pre>"},{"location":"typeclasses/survey/#maybe","title":"Maybe","text":"repl example<pre><code>&gt; maybeChar = Just 'a'\n&gt; :t maybeChar\nmaybeChar :: Maybe Char\n&gt; fmap (=='a') maybeChar\nJust True\n\n&gt; :t fmap (=='a') maybeChar\nfmap (=='a') maybeChar :: Maybe Bool\n\n&gt; fmap (=='a') Nothing\nNothing\n</code></pre>"},{"location":"typeclasses/survey/#either-a","title":"Either a","text":"<p>Note</p> <p><code>Either a</code> is <code>Either</code> partially applied to <code>a</code>, and has kind <code>* -&gt; *</code> as required.</p>  repl example<pre><code>&gt; eitherChar = Right 'a'\n&gt; :t eitherChar\neitherChar :: Either a Char -- (1)!\n&gt; fmap (=='a') eitherChar\nRight True\n\n&gt; :t fmap (=='a') eitherChar\nfmap (=='a') eitherChar :: Either a Bool\n\n&gt; other = Left True\n&gt; :t other\nother :: Either Bool b\n&gt; fmap (=='a') other\nLeft True\n&gt; :t fmap (=='a') other\nfmap (=='a') other :: Either Bool Bool -- (2)!\n</code></pre> <ol> <li> <p>Haskell correctly infers that <code>a</code> can be any type.</p> </li> <li> <p>Haskell correctly infers the type, which is no longer universally quantified.</p> </li> </ol>"},{"location":"typeclasses/survey/#reader-r","title":"Reader r","text":"<pre><code>newtype Reader r a = Reader {runReader :: r -&gt; a}\n</code></pre> <p>So, for example, <code>Reader Int Bool</code> is really just a wrapper around a function <code>Int -&gt; Bool</code>.</p> <p>Conceptually, think of a <code>Reader env a</code> as a value of type <code>a</code> that has access to (i.e. depends on) a value of type <code>env</code>. </p> <p>An example:</p> repl example<pre><code>&gt; import Control.Monad.Reader -- (1)!\n&gt; val = reader -- (2)!\n    (\\flag -&gt; if flag then \"hello world\" else \"no greeting\")\n&gt; runReader val True\n\"hello world\"\n&gt; runReader val False\n\"no greeting\"\n\n-- example of fmap\n&gt; newVal = fmap (take 5) val\n&gt; runReader newVal True\n\"hello\"\n</code></pre> <ol> <li>From the <code>mtl</code> package.</li> <li><code>mtl</code> doesn't define <code>Reader</code> exactly as shown above, so use lowercase <code>reader</code> to construct a value of type <code>Reader err a</code>, rather than uppercase <code>Reader</code>.</li> </ol>"},{"location":"typeclasses/survey/#state-s","title":"State s","text":"<pre><code>newtype State s a = State {runState :: s -&gt; (a, s) }\n</code></pre> <p>So, for example, <code>State Int Bool</code> is really just a wrapper around a function <code>Int -&gt; (Bool, Int)</code>.</p> <p>Conceptually, think of a <code>State st a</code> as a value of type <code>a</code> that requires a value of type <code>s</code> to be obtained, and results in a new value of type <code>s</code>.</p> <p>Example:</p> repl example<pre><code>&gt; val = state (\\ls -&gt; if length ls &gt; 3 then (Just (head ls), drop 1 ls) else (Nothing, ls))\n&gt; runState val [1,2,3]\n(Nothing,[1,2,3])\n&gt; runState val [1,2,3,4]\n(Just 1,[2,3,4])\n\n-- example of fmap\n&gt; import Data.Maybe\n&gt; newVal = fmap isJust val\n&gt; runState newVal [1,2,3]\n(False,[1,2,3])\n&gt; runState newVal [1,2,3,4]\n(True,[2,3,4])\n</code></pre>"},{"location":"typeclasses/survey/#applicative","title":"Applicative","text":"<pre><code>class Functor f =&gt; Applicative f where\n  pure :: a -&gt; f a\n  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c\n</code></pre> repl example<pre><code>&gt; import Control.Applicative\n\n-- examples with []\n&gt; pure 1 :: [Int]\n[1]\n&gt; liftA2 (+) [1,2,3] [2,3,4]\n[3,4,5,4,5,6,5,6,7]\n&gt; liftA2 (\\x y -&gt; (x,y)) ['a', 'b'] [True, False, True]\n[('a',True),('a',False),('a',True),('b',True),('b',False),('b',True)]\n\n-- examples with Maybe\n&gt; data Color = Black | White deriving Show\n&gt; pure Black :: Maybe Color\nJust Black\n&gt; liftA2 (+) (Just 3) (Just 4)\nJust 7\n&gt; liftA2 (+) (Just 3) Nothing\nNothing\n&gt; liftA2 (+) Nothing (Just 5)\nNothing\n\n\n-- examples with Reader\n&gt; boringVal = pure True :: Reader Int Bool\n&gt; runReader boringVal 4\nTrue\n&gt; runReader boringVal 3\nTrue\n\n-- example of liftA2\nval = reader (\\flag -&gt; if flag then \"hello world\" else \"no greeting\")\n&gt; combinedVal = liftA2 (&lt;&gt;) val val\n&gt; runReader combinedVal True\n\"hello worldhello world\"\n&gt; runReader combinedVal False\n\"no greetingno greeting\"\n</code></pre>  <p>Note</p> <p><code>liftA2</code> and <code>pure</code> can be used to define:</p> <pre><code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre> <p>and conversely, <code>&lt;*&gt;</code> and <code>pure</code> can be used to define <code>liftA2</code>. For this reason, <code>pure</code> and <code>&lt;*&gt;</code> are also sometimes given as the basic methods of <code>Applicative</code>.</p>"},{"location":"typeclasses/survey/#monad","title":"Monad","text":"<pre><code>class Applicative m =&gt; Monad m where\n  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b\n</code></pre>  <p>Note</p> <p>For legacy reasons, <code>Monad</code> also has a method <code>return</code>, which is a synonym for <code>pure</code>, and is therefore redundant, because all <code>Monad</code> instances are also <code>Applicative</code> instances and so have access to the <code>pure</code> method.</p>   <p>Hint</p> <p>Compare the type of <code>(&gt;&gt;=)</code> with the type of <code>fmap</code>. In <code>fmap</code>, the function <code>f</code> in <code>fmap f x</code> has type <code>a -&gt; b</code>, but in <code>(&gt;&gt;=)</code>, it has type <code>a -&gt; m b</code>.</p> <p>As a concrete example, consider lists:</p> <ul> <li><code>fmap :: (a -&gt; b) -&gt; ([a] -&gt; [b])</code></li> <li><code>(&gt;&gt;=) :: (a -&gt; [b]) -&gt; ([a] -&gt; [b])</code></li> </ul>  repl example<pre><code>-- lists\n&gt; upTo5 c = [c .. 5]\n&gt; [1,2,3,4] &gt;&gt;= upTo5\n[1,2,3,4,5,2,3,4,5,3,4,5,4,5]\n\n&gt; Just True &gt;&gt;= (\\x -&gt; if x then Just 1 else Nothing)\nJust 1\n&gt; Just False &gt;&gt;= (\\x -&gt; if x then Just 1 else Nothing)\nNothing\n&gt; Nothing &gt;&gt;= (\\x -&gt; if x then Just 1 else Nothing)\nNothing\n</code></pre> <p>Using do-notation, the first example above becomes:</p> <pre><code>example = do\n    i &lt;- [1,2,3,4]\n    pure (upTo5 i)\n</code></pre> <p>An illustrative example with <code>State</code>:</p> <pre><code>example :: State [Int] Bool\nexample = do\n    stack &lt;- get\n    let headIsGreaterThan3 = head stack &gt; 3\n    if headIsGreaterThan3\n        then put (tail stack)\n        else pure ()\n    return headIsGreaterThan3\n\n-- &gt; runState example [1,2,3]\n-- (False,[1,2,3])\n-- &gt; runState example [4,2,3]\n-- (True,[2,3])\n</code></pre>"},{"location":"typeclasses/survey/#alternative","title":"Alternative","text":"<pre><code>class Applicative f =&gt; Alternative f where\n  empty :: f a\n  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a\n</code></pre> <p>This is like <code>Monoid</code> but for a value of type <code>f a</code>, where <code>f</code> is an instance of <code>Applicative</code>. Parsers are a common use case.</p> <p>Another is backtracking search which uses the <code>Alternative</code> instance of the Logic monad.</p> <p>Other instances include <code>Maybe</code> and <code>[]</code>.</p>"}]}